--- a/NEWS
+++ b/NEWS
@@ -1,15 +1,48 @@
 PHP                                                                        NEWS
 |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+?? ??? 2013, PHP 5.5.0 Release Candidate 1
+
+- FPM:
+  . Ignore QUERY_STRING when sent in SCRIPT_FILENAME. (Remi)
+  . Fixed some possible memory or resource leaks and possible null dereference
+    detected by code coverity scan. (Remi)
+  . Log a warning when a syscall fails. (Remi)
+
+- GD:
+  . Fix build with system libgd >= 2.1 which is now the minimal
+    version required (as build with previous version is broken).
+    No change when bundled libgd is used.  (Ondrej Sury, Remi)
+
+- SNMP:
+  . Fixed bug #64765 (Some IPv6 addresses get interpreted wrong).
+    (Boris Lytochkin)
+  . Fixed bug #64159 (Truncated snmpget). (Boris Lytochkin)
+
+- Streams:
+  . Fixed bug #64770 (stream_select() fails with pipes returned by proc_open()
+    on Windows x64). (Anatol)
+
 25 Apr 2013, PHP 5.5.0 Beta 4
 
 - Core:
   . Fixed bug #64677 (execution operator `` stealing surrounding arguments). 
     (Laruence)
 
+- CURL:
+  . Remove curl stream wrappers. (Pierrick)
+
+- MySQLi:
+  . Fixed bug #64726 (Segfault when calling fetch_object on a use_result and DB
+    pointer has closed). (Laruence)
+
 - Zip:
   . Fixed bug #64342 (ZipArchive::addFile() has to check for file existence).
     (Anatol)
 
+- SOAP:
+  . Added SoapClient constructor option 'ssl_method' to specify ssl method.
+    (Eric Iversen)
+
 - Streams:
   . Fixed Windows x64 version of stream_socket_pair() and improved error handling
     (Anatol Belski)
--- a/Zend/zend_alloc.c
+++ b/Zend/zend_alloc.c
@@ -672,7 +672,7 @@ static inline unsigned int zend_mm_high_
 #elif defined(__GNUC__) && defined(__x86_64__)
 	unsigned long n;
 
-        __asm__("bsrq %1,%0\n\t" : "=r" (n) : "rm"  (_size) : "cc");
+        __asm__("bsr %1,%0\n\t" : "=r" (n) : "rm"  (_size) : "cc");
         return (unsigned int)n;
 #elif defined(_MSC_VER) && defined(_M_IX86)
 	__asm {
@@ -700,12 +700,12 @@ static inline unsigned int zend_mm_low_b
 #elif defined(__GNUC__) && defined(__x86_64__)
         unsigned long n;
 
-        __asm__("bsfq %1,%0\n\t" : "=r" (n) : "rm"  (_size) : "cc");
+        __asm__("bsf %1,%0\n\t" : "=r" (n) : "rm"  (_size) : "cc");
         return (unsigned int)n;
 #elif defined(_MSC_VER) && defined(_M_IX86)
 	__asm {
 		bsf eax, _size
-	}
+   }
 #elif defined(__GNUC__) && (defined(__arm__) || defined(__aarch64__))
 	return __builtin_ctzl(_size);
 #else
@@ -2485,12 +2485,21 @@ static inline size_t safe_address(size_t
         size_t res = nmemb;
         unsigned long overflow = 0;
 
-        __asm__ ("mulq %3\n\taddq %4,%0\n\tadcq %1,%1"
+#ifdef __ILP32__ /* x32 */
+# define LP_SUFF "l"
+#else /* amd64 */
+# define LP_SUFF "q"
+#endif
+
+        __asm__ ("mul" LP_SUFF  " %3\n\t"
+                 "add %4,%0\n\t"
+                 "adc %1,%1"
              : "=&a"(res), "=&d" (overflow)
              : "%0"(res),
                "rm"(size),
                "rm"(offset));
 
+#undef LP_SUFF
         if (UNEXPECTED(overflow)) {
                 zend_error_noreturn(E_ERROR, "Possible integer overflow in memory allocation (%zu * %zu + %zu)", nmemb, size, offset);
                 return 0;
--- a/Zend/zend_builtin_functions.c
+++ b/Zend/zend_builtin_functions.c
@@ -1014,7 +1014,7 @@ ZEND_FUNCTION(get_object_vars)
 	while (zend_hash_get_current_data_ex(properties, (void **) &value, &pos) == SUCCESS) {
 		if (zend_hash_get_current_key_ex(properties, &key, &key_len, &num_index, 0, &pos) == HASH_KEY_IS_STRING) {
 			if (zend_check_property_access(zobj, key, key_len-1 TSRMLS_CC) == SUCCESS) {
-				zend_unmangle_property_name_ex(key, key_len - 1, &class_name, &prop_name, &prop_len);
+				zend_unmangle_property_name_ex(key, key_len - 1, &class_name, &prop_name, (int*) &prop_len);
 				/* Not separating references */
 				Z_ADDREF_PP(value);
 				add_assoc_zval_ex(return_value, prop_name, prop_len + 1, *value);
--- a/Zend/zend_compile.c
+++ b/Zend/zend_compile.c
@@ -288,7 +288,7 @@ ZEND_API zend_bool zend_is_compiling(TSR
 
 static zend_uint get_temporary_variable(zend_op_array *op_array) /* {{{ */
 {
-	return (zend_uint)EX_TMP_VAR_NUM(0, (op_array->T)++);
+	return (zend_uint)(zend_uintptr_t)EX_TMP_VAR_NUM(0, (op_array->T)++);
 }
 /* }}} */
 
--- a/Zend/zend_float.h
+++ b/Zend/zend_float.h
@@ -65,11 +65,13 @@ extern ZEND_API void zend_ensure_fpu_mod
 
  MS Visual C:
   - Since MSVC users tipically don't use autoconf or CMake, we will detect
-    MSVC via compile time define.
+    MSVC via compile time define. Floating point precision change isn't
+    supported on 64 bit platforms, so it's NOP. See
+    http://msdn.microsoft.com/en-us/library/c9676k6h(v=vs.110).aspx
 */
 
 /* MSVC detection (MSVC people usually don't use autoconf) */
-#ifdef _MSC_VER
+#if defined(_MSC_VER) && !defined(_WIN64)
 # if _MSC_VER >= 1500
    /* Visual C++ 2008 or higher, supports _controlfp_s */
 #  define HAVE__CONTROLFP_S
--- a/Zend/zend_multiply.h
+++ b/Zend/zend_multiply.h
@@ -35,8 +35,8 @@
 
 #define ZEND_SIGNED_MULTIPLY_LONG(a, b, lval, dval, usedval) do {	\
 	long __tmpvar; 													\
-	__asm__ ("imulq %3,%0\n"										\
-		"adcq $0,%1" 												\
+	__asm__ ("imul %3,%0\n"											\
+		"adc $0,%1" 												\
 			: "=r"(__tmpvar),"=r"(usedval) 							\
 			: "0"(a), "r"(b), "1"(0));								\
 	if (usedval) (dval) = (double) (a) * (double) (b);				\
--- a/ext/curl/config.w32
+++ b/ext/curl/config.w32
@@ -13,7 +13,7 @@ if (PHP_CURL != "no") {
 		&& (((PHP_ZLIB=="no") && (CHECK_LIB("zlib_a.lib;zlib.lib", "curl", PHP_CURL))) || 
 			(PHP_ZLIB_SHARED && CHECK_LIB("zlib.lib", "curl", PHP_CURL)) || (PHP_ZLIB == "yes" && (!PHP_ZLIB_SHARED)))
 		) {
-		EXTENSION("curl", "interface.c multi.c share.c streams.c curl_file.c", true);
+		EXTENSION("curl", "interface.c multi.c share.c curl_file.c", true);
 		AC_DEFINE('HAVE_CURL', 1, 'Have cURL library');
 		AC_DEFINE('HAVE_CURL_SSL', 1, 'Have SSL suppurt in cURL');
 		AC_DEFINE('HAVE_CURL_EASY_STRERROR', 1, 'Have curl_easy_strerror in cURL');
--- a/ext/date/lib/parse_date.c
+++ b/ext/date/lib/parse_date.c
@@ -1,4 +1,4 @@
-/* Generated by re2c 0.13.5 on Sun Mar 31 10:47:54 2013 */
+/* Generated by re2c 0.13.5 on Fri Apr 26 11:10:28 2013 */
 /*
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
@@ -24991,7 +24991,7 @@ timelib_time *timelib_parse_from_format(
 				break;
 
 			case '\\': /* escaped char */
-				*fptr++;
+				++fptr;
 				if (*ptr == *fptr) {
 					++ptr;
 				} else {
--- a/ext/date/lib/parse_date.re
+++ b/ext/date/lib/parse_date.re
@@ -2096,7 +2096,7 @@ timelib_time *timelib_parse_from_format(
 				break;
 
 			case '\\': /* escaped char */
-				*fptr++;
+				++fptr;
 				if (*ptr == *fptr) {
 					++ptr;
 				} else {
--- a/ext/date/php_date.c
+++ b/ext/date/php_date.c
@@ -614,13 +614,11 @@ static void date_object_free_storage_int
 static void date_object_free_storage_period(void *object TSRMLS_DC);
 
 static zend_object_value date_object_new_date(zend_class_entry *class_type TSRMLS_DC);
-static zend_object_value date_object_new_immutable(zend_class_entry *class_type TSRMLS_DC);
 static zend_object_value date_object_new_timezone(zend_class_entry *class_type TSRMLS_DC);
 static zend_object_value date_object_new_interval(zend_class_entry *class_type TSRMLS_DC);
 static zend_object_value date_object_new_period(zend_class_entry *class_type TSRMLS_DC);
 
 static zend_object_value date_object_clone_date(zval *this_ptr TSRMLS_DC);
-static zend_object_value date_object_clone_immutable(zval *this_ptr TSRMLS_DC);
 static zend_object_value date_object_clone_timezone(zval *this_ptr TSRMLS_DC);
 static zend_object_value date_object_clone_interval(zval *this_ptr TSRMLS_DC);
 static zend_object_value date_object_clone_period(zval *this_ptr TSRMLS_DC);
--- a/ext/fileinfo/libmagic.patch
+++ b/ext/fileinfo/libmagic.patch
@@ -1,6 +1,6 @@
 diff -u libmagic.orig/apprentice.c libmagic/apprentice.c
 --- libmagic.orig/apprentice.c	2013-03-21 18:45:14.000000000 +0100
-+++ libmagic/apprentice.c	2013-04-08 16:14:17.828357711 +0200
++++ libmagic/apprentice.c	2013-04-27 13:53:32.175250261 +0200
 @@ -29,6 +29,8 @@
   * apprentice - make one pass through /etc/magic, learning its secrets.
   */
@@ -352,7 +352,7 @@ diff -u libmagic.orig/apprentice.c libma
  		file_oomem(ms, slen);
  		return -1;
  	}
-@@ -1102,14 +1121,14 @@
+@@ -1102,27 +1121,29 @@
  	if (me == NULL)
  		return;
  	for (i = 0; i < nme; i++)
@@ -370,8 +370,9 @@ diff -u libmagic.orig/apprentice.c libma
  	struct magic_entry *mentry[MAGIC_SETS] = { NULL };
  	uint32_t mentrycount[MAGIC_SETS] = { 0 };
  	uint32_t i, j;
-@@ -1117,12 +1136,14 @@
- 	char **filearr = NULL, *mfn;
+ 	size_t files = 0, maxfiles = 0;
+-	char **filearr = NULL, *mfn;
++	char **filearr = NULL;
  	struct stat st;
  	struct magic_map *map;
 -	DIR *dir;
@@ -411,7 +412,7 @@ diff -u libmagic.orig/apprentice.c libma
 +		int mflen;
 +		char mfn[MAXPATHLEN];
 +
-+		dir = php_stream_opendir(fn, REPORT_ERRORS, NULL);
++		dir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);
  		if (!dir) {
  			errs++;
  			goto out;
@@ -578,7 +579,7 @@ diff -u libmagic.orig/apprentice.c libma
 +#ifdef PHP_WIN32
 +	/* Don't bother on windows with php_stream_open_wrapper,
 +	return to give apprentice_load() a chance. */
-+	if (php_stream_stat_path_ex(fn, 0, &st, NULL) == SUCCESS) {
++	if (php_stream_stat_path_ex((char *)fn, 0, &st, NULL) == SUCCESS) {
 +               if (st.sb.st_mode & S_IFDIR) {
 +                       goto error;
 +               }
@@ -751,7 +752,7 @@ diff -u libmagic.orig/apprentice.c libma
  	}
  
 -	if (write(fd, map->nmagic, nm) != (ssize_t)nm) {
-+	if (php_stream_write(stream, map->nmagic, nm) != (ssize_t)nm) {
++	if (php_stream_write(stream, (const char *)map->nmagic, nm) != (ssize_t)nm) {
  		file_error(ms, errno, "error writing `%s'", dbname);
  		goto out;
  	}
@@ -767,7 +768,7 @@ diff -u libmagic.orig/apprentice.c libma
  	for (i = 0; i < MAGIC_SETS; i++) {
  		len = m * map->nmagic[i];
 -		if (write(fd, map->magic[i], len) != (ssize_t)len) {
-+		if (php_stream_write(stream, map->magic[i], len) != (ssize_t)len) {
++		if (php_stream_write(stream, (const char *)map->magic[i], len) != (ssize_t)len) {
  			file_error(ms, errno, "error writing `%s'", dbname);
  			goto out;
  		}
@@ -2047,7 +2048,7 @@ diff -u libmagic.orig/funcs.c libmagic/f
 +
 diff -u libmagic.orig/magic.c libmagic/magic.c
 --- libmagic.orig/magic.c	2013-01-11 17:43:09.000000000 +0100
-+++ libmagic/magic.c	2013-04-08 15:42:57.328298809 +0200
++++ libmagic/magic.c	2013-04-27 13:53:32.175250261 +0200
 @@ -25,11 +25,6 @@
   * SUCH DAMAGE.
   */
@@ -2089,7 +2090,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  #if defined(HAVE_UTIMES)
  # include <sys/time.h>
  #elif defined(HAVE_UTIME)
-@@ -71,18 +75,24 @@
+@@ -71,18 +75,25 @@
  #endif
  #endif
  
@@ -2098,14 +2099,14 @@ diff -u libmagic.orig/magic.c libmagic/m
 +# undef S_IFIFO
 +#endif
 +
-+private void free_mlist(struct mlist *);
  private void close_and_restore(const struct magic_set *, const char *, int,
      const struct stat *);
  private int unreadable_info(struct magic_set *, mode_t, const char *);
++#if 0
  private const char* get_default_magic(void);
 -#ifndef COMPILE_ONLY
 -private const char *file_or_fd(struct magic_set *, const char *, int);
--#endif
+ #endif
 +private const char *file_or_stream(struct magic_set *, const char *, php_stream *);
  
  #ifndef	STDIN_FILENO
@@ -2117,7 +2118,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  private const char *
  get_default_magic(void)
  {
-@@ -90,7 +100,7 @@
+@@ -90,7 +101,7 @@
  	static char *default_magic;
  	char *home, *hmagicpath;
  
@@ -2126,7 +2127,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  	struct stat st;
  
  	if (default_magic) {
-@@ -104,17 +114,17 @@
+@@ -104,17 +115,17 @@
  		return MAGIC;
  	if (stat(hmagicpath, &st) == -1) {
  		free(hmagicpath);
@@ -2153,7 +2154,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  	}
  
  	if (asprintf(&default_magic, "%s:%s", hmagicpath, MAGIC) < 0)
-@@ -128,6 +138,7 @@
+@@ -128,6 +139,7 @@
  #else
  	char *hmagicp = hmagicpath;
  	char *tmppath = NULL;
@@ -2161,7 +2162,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  
  #define APPENDPATH() \
  	do { \
-@@ -172,7 +183,7 @@
+@@ -172,7 +184,7 @@
  	}
  
  	/* Third, try to get magic file relative to dll location */
@@ -2170,7 +2171,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  	dllpath[MAX_PATH] = 0;	/* just in case long path gets truncated and not null terminated */
  	if (GetModuleFileNameA(NULL, dllpath, MAX_PATH)){
  		PathRemoveFileSpecA(dllpath);
-@@ -210,6 +221,7 @@
+@@ -210,6 +222,7 @@
  
  	return action == FILE_LOAD ? get_default_magic() : MAGIC;
  }
@@ -2178,7 +2179,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  
  public struct magic_set *
  magic_open(int flags)
-@@ -250,7 +262,7 @@
+@@ -250,7 +263,7 @@
  magic_load(struct magic_set *ms, const char *magicfile)
  {
  	if (ms == NULL)
@@ -2187,7 +2188,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  	return file_apprentice(ms, magicfile, FILE_LOAD);
  }
  
-@@ -262,13 +274,6 @@
+@@ -262,13 +275,6 @@
  	return file_apprentice(ms, magicfile, FILE_COMPILE);
  }
  
@@ -2201,7 +2202,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  
  public int
  magic_list(struct magic_set *ms, const char *magicfile)
-@@ -282,9 +287,6 @@
+@@ -282,9 +288,6 @@
  close_and_restore(const struct magic_set *ms, const char *name, int fd,
      const struct stat *sb)
  {
@@ -2211,7 +2212,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  
  	if ((ms->flags & MAGIC_PRESERVE_ATIME) != 0) {
  		/*
-@@ -311,7 +313,6 @@
+@@ -311,7 +314,6 @@
  	}
  }
  
@@ -2219,7 +2220,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  
  /*
   * find type of descriptor
-@@ -321,7 +322,7 @@
+@@ -321,7 +323,7 @@
  {
  	if (ms == NULL)
  		return NULL;
@@ -2228,7 +2229,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  }
  
  /*
-@@ -332,30 +333,42 @@
+@@ -332,30 +334,42 @@
  {
  	if (ms == NULL)
  		return NULL;
@@ -2277,7 +2278,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  	case -1:		/* error */
  		goto done;
  	case 0:			/* nothing found */
-@@ -365,68 +378,48 @@
+@@ -365,68 +379,48 @@
  		goto done;
  	}
  
@@ -2372,7 +2373,7 @@ diff -u libmagic.orig/magic.c libmagic/m
  	return rv == 0 ? file_getbuffer(ms) : NULL;
  }
  
-@@ -440,14 +433,13 @@
+@@ -440,14 +434,13 @@
  		return NULL;
  	/*
  	 * The main work is done here!
@@ -2410,8 +2411,8 @@ diff -u libmagic.orig/magic.h libmagic/m
  
 diff -u libmagic.orig/print.c libmagic/print.c
 --- libmagic.orig/print.c	2013-03-21 18:45:14.000000000 +0100
-+++ libmagic/print.c	2013-04-08 15:42:57.328298809 +0200
-@@ -28,6 +28,8 @@
++++ libmagic/print.c	2013-04-27 13:53:32.175250261 +0200
+@@ -28,13 +28,17 @@
  /*
   * print.c - debugging printout routines
   */
@@ -2419,8 +2420,9 @@ diff -u libmagic.orig/print.c libmagic/p
 +#include "php.h"
  
  #include "file.h"
++#include "cdf.h"
  
-@@ -35,6 +37,7 @@
+ #ifndef lint
  FILE_RCSID("@(#)$File: print.c,v 1.76 2013/02/26 18:25:00 christos Exp $")
  #endif  /* lint */
  
@@ -2428,7 +2430,7 @@ diff -u libmagic.orig/print.c libmagic/p
  #include <string.h>
  #include <stdarg.h>
  #include <stdlib.h>
-@@ -43,188 +46,28 @@
+@@ -43,188 +47,28 @@
  #endif
  #include <time.h>
  
@@ -2619,7 +2621,7 @@ diff -u libmagic.orig/print.c libmagic/p
 -	(void) fprintf(stderr, "Warning: ");
  	va_start(va, f);
 -	(void) vfprintf(stderr, f, va);
-+	vasprintf(&expanded_format, f, va);
++	if (vasprintf(&expanded_format, f, va)); /* silence */
  	va_end(va);
 -	(void) fputc('\n', stderr);
 +	
@@ -2629,7 +2631,7 @@ diff -u libmagic.orig/print.c libmagic/p
  }
  
  protected const char *
-@@ -235,7 +78,7 @@
+@@ -235,7 +79,7 @@
  	struct tm *tm;
  
  	if (flags & FILE_T_WINDOWS) {
--- a/ext/fileinfo/libmagic/apprentice.c
+++ b/ext/fileinfo/libmagic/apprentice.c
@@ -1133,7 +1133,7 @@ apprentice_load(struct magic_set *ms, co
 	uint32_t mentrycount[MAGIC_SETS] = { 0 };
 	uint32_t i, j;
 	size_t files = 0, maxfiles = 0;
-	char **filearr = NULL, *mfn;
+	char **filearr = NULL;
 	struct stat st;
 	struct magic_map *map;
 	php_stream *dir;
@@ -1169,7 +1169,7 @@ apprentice_load(struct magic_set *ms, co
 		int mflen;
 		char mfn[MAXPATHLEN];
 
-		dir = php_stream_opendir(fn, REPORT_ERRORS, NULL);
+		dir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);
 		if (!dir) {
 			errs++;
 			goto out;
@@ -2613,7 +2613,7 @@ apprentice_map(struct magic_set *ms, con
 #ifdef PHP_WIN32
 	/* Don't bother on windows with php_stream_open_wrapper,
 	return to give apprentice_load() a chance. */
-	if (php_stream_stat_path_ex(fn, 0, &st, NULL) == SUCCESS) {
+	if (php_stream_stat_path_ex((char *)fn, 0, &st, NULL) == SUCCESS) {
                if (st.sb.st_mode & S_IFDIR) {
                        goto error;
                }
@@ -2778,7 +2778,7 @@ apprentice_compile(struct magic_set *ms,
 		goto out;
 	}
 
-	if (php_stream_write(stream, map->nmagic, nm) != (ssize_t)nm) {
+	if (php_stream_write(stream, (const char *)map->nmagic, nm) != (ssize_t)nm) {
 		file_error(ms, errno, "error writing `%s'", dbname);
 		goto out;
 	}
@@ -2792,7 +2792,7 @@ apprentice_compile(struct magic_set *ms,
 
 	for (i = 0; i < MAGIC_SETS; i++) {
 		len = m * map->nmagic[i];
-		if (php_stream_write(stream, map->magic[i], len) != (ssize_t)len) {
+		if (php_stream_write(stream, (const char *)map->magic[i], len) != (ssize_t)len) {
 			file_error(ms, errno, "error writing `%s'", dbname);
 			goto out;
 		}
--- a/ext/fileinfo/libmagic/magic.c
+++ b/ext/fileinfo/libmagic/magic.c
@@ -80,11 +80,12 @@ FILE_RCSID("@(#)$File: magic.c,v 1.78 20
 # undef S_IFIFO
 #endif
 
-private void free_mlist(struct mlist *);
 private void close_and_restore(const struct magic_set *, const char *, int,
     const struct stat *);
 private int unreadable_info(struct magic_set *, mode_t, const char *);
+#if 0
 private const char* get_default_magic(void);
+#endif
 private const char *file_or_stream(struct magic_set *, const char *, php_stream *);
 
 #ifndef	STDIN_FILENO
--- a/ext/fileinfo/libmagic/print.c
+++ b/ext/fileinfo/libmagic/print.c
@@ -32,6 +32,7 @@
 #include "php.h"
 
 #include "file.h"
+#include "cdf.h"
 
 #ifndef lint
 FILE_RCSID("@(#)$File: print.c,v 1.76 2013/02/26 18:25:00 christos Exp $")
@@ -62,7 +63,7 @@ file_magwarn(struct magic_set *ms, const
 	TSRMLS_FETCH();
 
 	va_start(va, f);
-	vasprintf(&expanded_format, f, va);
+	if (vasprintf(&expanded_format, f, va)); /* silence */
 	va_end(va);
 	
 	php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Warning: %s", expanded_format);
--- a/ext/gd/config.m4
+++ b/ext/gd/config.m4
@@ -9,7 +9,6 @@ dnl
 PHP_ARG_WITH(gd, for GD support,
 [  --with-gd[=DIR]         Include GD support.  DIR is the GD library base
                           install directory [BUNDLED]])
-
 if test -z "$PHP_VPX_DIR"; then
   PHP_ARG_WITH(vpx-dir, for the location of libvpx,
   [  --with-vpx-dir[=DIR]     GD: Set the path to libvpx install prefix], no, no)
@@ -159,18 +158,11 @@ AC_DEFUN([PHP_GD_XPM],[
   if test "$PHP_XPM_DIR" != "no"; then
 
     for i in $PHP_XPM_DIR /usr/local /usr/X11R6 /usr; do
-      test -f $i/$PHP_LIBDIR/libXpm.$SHLIB_SUFFIX_NAME || test -f $i/$PHP_LIBDIR/libXpm.a && GD_XPM_DIR=$i && break
+      test -f $i/include/xpm.h && GD_XPM_DIR=$i && GD_XPM_INC=$i && break
+      test -f $i/include/X11/xpm.h && GD_XPM_DIR=$i && GD_XPM_INC=$i/X11 && break
     done
 
     if test -z "$GD_XPM_DIR"; then
-      AC_MSG_ERROR([libXpm.(a|so) not found.])
-    fi
-
-    for i in include include/X11; do
-      test -f $GD_XPM_DIR/$i/xpm.h && GD_XPM_INC=$GD_XPM_DIR/include
-    done
-
-    if test -z "$GD_XPM_INC"; then
       AC_MSG_ERROR([xpm.h not found.])
     fi
 
@@ -259,39 +251,33 @@ AC_DEFUN([PHP_GD_JISX0208],[
 ])
 
 AC_DEFUN([PHP_GD_CHECK_VERSION],[
-  PHP_CHECK_LIBRARY(gd, gdImageString16,        [AC_DEFINE(HAVE_LIBGD13,             1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImagePaletteCopy,     [AC_DEFINE(HAVE_LIBGD15,             1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageCreateFromPng,   [AC_DEFINE(HAVE_GD_PNG,              1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageCreateFromGif,   [AC_DEFINE(HAVE_GD_GIF_READ,         1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageGif,             [AC_DEFINE(HAVE_GD_GIF_CREATE,       1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageWBMP,            [AC_DEFINE(HAVE_GD_WBMP,             1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageCreateFromWebp,  [AC_DEFINE(HAVE_GD_WEBP,             1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageCreateFromJpeg,  [AC_DEFINE(HAVE_GD_JPG,              1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageCreateFromXpm,   [AC_DEFINE(HAVE_GD_XPM,              1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageCreateFromGd2,   [AC_DEFINE(HAVE_GD_GD2,              1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageCreateTrueColor, [AC_DEFINE(HAVE_LIBGD20,             1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageSetTile,         [AC_DEFINE(HAVE_GD_IMAGESETTILE,     1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageEllipse,         [AC_DEFINE(HAVE_GD_IMAGEELLIPSE,     1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageSetBrush,        [AC_DEFINE(HAVE_GD_IMAGESETBRUSH,    1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageStringTTF,       [AC_DEFINE(HAVE_GD_STRINGTTF,        1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageStringFT,        [AC_DEFINE(HAVE_GD_STRINGFT,         1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageStringFTEx,      [AC_DEFINE(HAVE_GD_STRINGFTEX,       1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageColorClosestHWB, [AC_DEFINE(HAVE_COLORCLOSESTHWB,     1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageColorResolve,    [AC_DEFINE(HAVE_GDIMAGECOLORRESOLVE, 1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageGifCtx,          [AC_DEFINE(HAVE_GD_GIF_CTX,          1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdCacheCreate,          [AC_DEFINE(HAVE_GD_CACHE_CREATE,     1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdFontCacheShutdown,    [AC_DEFINE(HAVE_GD_FONTCACHESHUTDOWN,1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdFreeFontCache,        [AC_DEFINE(HAVE_GD_FREEFONTCACHE,    1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdFontCacheMutexSetup,  [AC_DEFINE(HAVE_GD_FONTMUTEX,        1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdNewDynamicCtxEx,      [AC_DEFINE(HAVE_GD_DYNAMIC_CTX_EX,   1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImageConvolution,     [AC_DEFINE(HAVE_GD_IMAGE_CONVOLUTION,      1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
-  PHP_CHECK_LIBRARY(gd, gdImagePixelate,        [AC_DEFINE(HAVE_GD_IMAGE_PIXELATE,         1, [ ])], [], [ -L$GD_LIB $GD_SHARED_LIBADD ])
+  PHP_CHECK_LIBRARY(gd, gdImageCreateFromPng,   [AC_DEFINE(HAVE_GD_PNG,              1, [ ])], [], [ $GD_SHARED_LIBADD ])
+  PHP_CHECK_LIBRARY(gd, gdImageCreateFromWebp,  [AC_DEFINE(HAVE_GD_WEBP,             1, [ ])], [], [ $GD_SHARED_LIBADD ])
+  PHP_CHECK_LIBRARY(gd, gdImageCreateFromJpeg,  [AC_DEFINE(HAVE_GD_JPG,              1, [ ])], [], [ $GD_SHARED_LIBADD ])
+  PHP_CHECK_LIBRARY(gd, gdImageCreateFromXpm,   [AC_DEFINE(HAVE_GD_XPM,              1, [ ])], [], [ $GD_SHARED_LIBADD ])
+  PHP_CHECK_LIBRARY(gd, gdImageStringFT,        [AC_DEFINE(HAVE_GD_FREETYPE,         1, [ ])], [], [ $GD_SHARED_LIBADD ])
 ])
 
 dnl
 dnl Main GD configure
 dnl
 
+dnl
+dnl Common for both builtin and external GD
+dnl
+if test "$PHP_GD" != "no"; then
+dnl Various checks for GD features
+  PHP_GD_ZLIB
+  PHP_GD_TTSTR
+  PHP_GD_VPX
+  PHP_GD_JPEG
+  PHP_GD_PNG
+  PHP_GD_XPM
+  PHP_GD_FREETYPE2
+  PHP_GD_T1LIB
+  PHP_GD_JISX0208
+fi
+
 if test "$PHP_GD" = "yes"; then
   GD_MODULE_TYPE=builtin
   extra_sources="libgd/gd.c libgd/gd_gd.c libgd/gd_gd2.c libgd/gd_io.c libgd/gd_io_dp.c \
@@ -301,7 +287,7 @@ if test "$PHP_GD" = "yes"; then
                  libgd/gdcache.c libgd/gdkanji.c libgd/wbmp.c libgd/gd_wbmp.c libgd/gdhelpers.c \
                  libgd/gd_topal.c libgd/gd_gif_in.c libgd/xbm.c libgd/gd_gif_out.c libgd/gd_security.c \
                  libgd/gd_filter.c libgd/gd_pixelate.c libgd/gd_arc.c libgd/gd_rotate.c libgd/gd_color.c \
-				 libgd/gd_transform.c libgd/gd_crop.c libgd/gd_interpolation.c libgd/gd_matrix.c"
+                 libgd/gd_transform.c libgd/gd_crop.c libgd/gd_interpolation.c libgd/gd_matrix.c"
 
 dnl check for fabsf and floorf which are available since C99
   AC_CHECK_FUNCS(fabsf floorf)
@@ -309,39 +295,10 @@ dnl check for fabsf and floorf which are
 dnl PNG is required by GD library
   test "$PHP_PNG_DIR" = "no" && PHP_PNG_DIR=yes
 
-dnl Various checks for GD features
-  PHP_GD_ZLIB
-  PHP_GD_TTSTR
-  PHP_GD_JISX0208
-  PHP_GD_JPEG
-  PHP_GD_VPX
-  PHP_GD_PNG
-  PHP_GD_XPM
-  PHP_GD_FREETYPE2
-  PHP_GD_T1LIB
-
 dnl These are always available with bundled library
-  AC_DEFINE(HAVE_LIBGD,               1, [ ])
-  AC_DEFINE(HAVE_LIBGD13,             1, [ ])
-  AC_DEFINE(HAVE_LIBGD15,             1, [ ])
-  AC_DEFINE(HAVE_LIBGD20,             1, [ ])
-  AC_DEFINE(HAVE_LIBGD204,            1, [ ])
-  AC_DEFINE(HAVE_GD_IMAGESETTILE,     1, [ ])
-  AC_DEFINE(HAVE_GD_IMAGESETBRUSH,    1, [ ])
-  AC_DEFINE(HAVE_GDIMAGECOLORRESOLVE, 1, [ ])
-  AC_DEFINE(HAVE_COLORCLOSESTHWB,     1, [ ])
-  AC_DEFINE(HAVE_GD_WBMP,             1, [ ])
-  AC_DEFINE(HAVE_GD_GD2,              1, [ ])
-  AC_DEFINE(HAVE_GD_PNG,              1, [ ])
-  AC_DEFINE(HAVE_GD_XBM,              1, [ ])
   AC_DEFINE(HAVE_GD_BUNDLED,          1, [ ])
-  AC_DEFINE(HAVE_GD_GIF_READ,         1, [ ])
-  AC_DEFINE(HAVE_GD_GIF_CREATE,       1, [ ])
-  AC_DEFINE(HAVE_GD_IMAGEELLIPSE,     1, [ ])
-  AC_DEFINE(HAVE_GD_FONTCACHESHUTDOWN,1, [ ])
-  AC_DEFINE(HAVE_GD_FONTMUTEX,        1, [ ])
-  AC_DEFINE(HAVE_GD_DYNAMIC_CTX_EX,   1, [ ])
-  AC_DEFINE(HAVE_GD_GIF_CTX,          1, [ ])
+  AC_DEFINE(HAVE_GD_PNG,              1, [ ])
+  AC_DEFINE(HAVE_GD_CACHE_CREATE,     1, [ ])
 
 dnl Make sure the libgd/ is first in the include path
   GDLIB_CFLAGS="-DHAVE_LIBPNG"
@@ -365,8 +322,7 @@ dnl enable the support in bundled GD lib
   fi
 
   if test -n "$FREETYPE2_DIR"; then
-    AC_DEFINE(HAVE_GD_STRINGFT,   1, [ ])
-    AC_DEFINE(HAVE_GD_STRINGFTEX, 1, [ ])
+    AC_DEFINE(HAVE_GD_FREETYPE,   1, [ ])
     AC_DEFINE(ENABLE_GD_TTF, 1, [ ])
     GDLIB_CFLAGS="$GDLIB_CFLAGS -DHAVE_LIBFREETYPE -DENABLE_GD_TTF"
   fi
@@ -380,8 +336,7 @@ else
 
  if test "$PHP_GD" != "no"; then
   GD_MODULE_TYPE=external
-  extra_sources="gdcache.c libgd/gd_compat.c libgd/gd_filter.c libgd/gd_pixelate.c libgd/gd_arc.c \
-                 libgd/gd_rotate.c libgd/gd_color.c"
+  extra_sources="gd_compat.c"
 
 dnl Various checks for GD features
   PHP_GD_ZLIB
@@ -394,44 +349,28 @@ dnl Various checks for GD features
   PHP_GD_T1LIB
 
 dnl Header path
-  for i in include/gd1.3 include/gd include gd1.3 gd ""; do
+  for i in include/gd include gd ""; do
     test -f "$PHP_GD/$i/gd.h" && GD_INCLUDE="$PHP_GD/$i"
   done
 
-dnl Library path
-  for i in $PHP_LIBDIR/gd1.3 $PHP_LIBDIR/gd $PHP_LIBDIR gd1.3 gd ""; do
-    test -f "$PHP_GD/$i/libgd.$SHLIB_SUFFIX_NAME" || test -f "$PHP_GD/$i/libgd.a" && GD_LIB="$PHP_GD/$i"
-  done
-
-  if test -n "$GD_INCLUDE" && test -n "$GD_LIB"; then
-    PHP_ADD_LIBRARY_WITH_PATH(gd, $GD_LIB, GD_SHARED_LIBADD)
-    AC_DEFINE(HAVE_LIBGD,1,[ ])
-    PHP_GD_CHECK_VERSION
-  elif test -z "$GD_INCLUDE"; then
+  if test -z "$GD_INCLUDE"; then
     AC_MSG_ERROR([Unable to find gd.h anywhere under $PHP_GD])
-  else
-    AC_MSG_ERROR([Unable to find libgd.(a|so) anywhere under $PHP_GD])
   fi
 
-  PHP_EXPAND_PATH($GD_INCLUDE, GD_INCLUDE)
+dnl Library path
 
-  dnl
-  dnl Check for gd 2.0.4 greater availability
-  dnl
-  old_CPPFLAGS=$CPPFLAGS
-  CPPFLAGS=-I$GD_INCLUDE
-  AC_TRY_COMPILE([
-#include <gd.h>
-#include <stdlib.h>
-  ], [
-gdIOCtx *ctx;
-ctx = malloc(sizeof(gdIOCtx));
-ctx->gd_free = 1;
-  ], [
-    AC_DEFINE(HAVE_LIBGD204, 1, [ ])
+  PHP_CHECK_LIBRARY(gd, gdSetErrorMethod,
+  [
+    PHP_ADD_LIBRARY_WITH_PATH(gd, $PHP_GD/$PHP_LIBDIR, GD_SHARED_LIBADD)
+    AC_DEFINE(HAVE_LIBGD, 1, [ ])
+  ],[
+    AC_MSG_ERROR([Unable to find libgd.(a|so) >= 2.1.0 anywhere under $PHP_GD])
+  ],[
+    -L$PHP_GD/$PHP_LIBDIR
   ])
-  CPPFLAGS=$old_CPPFLAGS
+  PHP_GD_CHECK_VERSION
 
+  PHP_EXPAND_PATH($GD_INCLUDE, GD_INCLUDE)
  fi
 fi
 
@@ -441,9 +380,8 @@ dnl
 if test "$PHP_GD" != "no"; then
   PHP_NEW_EXTENSION(gd, gd.c $extra_sources, $ext_shared,, \\$(GDLIB_CFLAGS))
 
-  PHP_ADD_BUILD_DIR($ext_builddir/libgd)
-
-  if test "$GD_MODULE_TYPE" = "builtin"; then
+  if test "$GD_MODULE_TYPE" = "builtin"; then 
+    PHP_ADD_BUILD_DIR($ext_builddir/libgd)
     GDLIB_CFLAGS="-I$ext_srcdir/libgd $GDLIB_CFLAGS"
     GD_HEADER_DIRS="ext/gd/ ext/gd/libgd/"
 
@@ -456,7 +394,7 @@ if test "$PHP_GD" != "no"; then
     PHP_ADD_INCLUDE($GD_INCLUDE)
     PHP_CHECK_LIBRARY(gd, gdImageCreate, [], [
       AC_MSG_ERROR([GD build test failed. Please check the config.log for details.])
-    ], [ -L$GD_LIB $GD_SHARED_LIBADD ])
+    ], [ $GD_SHARED_LIBADD ])
   fi
 
   PHP_INSTALL_HEADERS([$GD_HEADER_DIRS])
--- a/ext/gd/gd.c
+++ b/ext/gd/gd.c
@@ -53,11 +53,14 @@
 # include <Wingdi.h>
 #endif
 
-#if HAVE_LIBGD
-#if !HAVE_GD_BUNDLED
-# include "libgd/gd_compat.h"
+#ifdef HAVE_GD_XPM
+# include <X11/xpm.h>
 #endif
 
+#ifndef HAVE_GD_BUNDLED
+# include "gd_compat.h"
+#endif /* HAVE_GD_BUNDLED */
+
 static int le_gd, le_gd_font;
 #if HAVE_LIBT1
 #include <t1lib.h>
@@ -73,9 +76,6 @@ static void php_free_ps_enc(zend_rsrc_li
 #include <gdfontl.h>  /* 4 Large font */
 #include <gdfontg.h>  /* 5 Giant font */
 
-#ifdef HAVE_GD_WBMP
-#include "libgd/wbmp.h"
-#endif
 #ifdef ENABLE_GD_TTF
 # ifdef HAVE_LIBFREETYPE
 #  include <ft2build.h>
@@ -91,38 +91,7 @@ static void php_free_ps_enc(zend_rsrc_li
 static void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int, int);
 #endif
 
-#if HAVE_LIBGD15
-/* it's >= 1.5, i.e. has IOCtx */
-#define USE_GD_IOCTX 1
-#else
-#undef USE_GD_IOCTX
-#endif
-
-#ifdef USE_GD_IOCTX
 #include "gd_ctx.c"
-#else
-#define gdImageCreateFromGdCtx      NULL
-#define gdImageCreateFromGd2Ctx     NULL
-#define gdImageCreateFromGd2partCtx NULL
-#define gdImageCreateFromGifCtx     NULL
-#define gdImageCreateFromJpegCtx    NULL
-#define gdImageCreateFromPngCtx     NULL
-#define gdImageCreateFromWBMPCtx    NULL
-typedef FILE gdIOCtx;
-#define CTX_PUTC(c, fp) fputc(c, fp)
-#endif
-
-#ifndef HAVE_GDIMAGECOLORRESOLVE
-extern int gdImageColorResolve(gdImagePtr, int, int, int);
-#endif
-
-#if HAVE_COLORCLOSESTHWB
-int gdImageColorClosestHWB(gdImagePtr im, int r, int g, int b);
-#endif
-
-#ifndef HAVE_GD_DYNAMIC_CTX_EX
-#define gdNewDynamicCtxEx(len, data, val) gdNewDynamicCtx(len, data)
-#endif
 
 /* Section Filters Declarations */
 /* IMPORTANT NOTE FOR NEW FILTER
@@ -239,12 +208,10 @@ ZEND_BEGIN_ARG_INFO(arginfo_imagesavealp
 	ZEND_ARG_INFO(0, save)
 ZEND_END_ARG_INFO()
 
-#if HAVE_GD_BUNDLED
 ZEND_BEGIN_ARG_INFO(arginfo_imagelayereffect, 0)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, effect)
 ZEND_END_ARG_INFO()
-#endif
 
 ZEND_BEGIN_ARG_INFO(arginfo_imagecolorallocatealpha, 0)
 	ZEND_ARG_INFO(0, im)
@@ -308,19 +275,15 @@ ZEND_BEGIN_ARG_INFO_EX(arginfo_imagerota
 	ZEND_ARG_INFO(0, ignoretransparent)
 ZEND_END_ARG_INFO()
 
-#if HAVE_GD_IMAGESETTILE
 ZEND_BEGIN_ARG_INFO(arginfo_imagesettile, 0)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, tile)
 ZEND_END_ARG_INFO()
-#endif
 
-#if HAVE_GD_IMAGESETBRUSH
 ZEND_BEGIN_ARG_INFO(arginfo_imagesetbrush, 0)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, brush)
 ZEND_END_ARG_INFO()
-#endif
 
 ZEND_BEGIN_ARG_INFO(arginfo_imagecreate, 0)
 	ZEND_ARG_INFO(0, x_size)
@@ -330,17 +293,13 @@ ZEND_END_ARG_INFO()
 ZEND_BEGIN_ARG_INFO(arginfo_imagetypes, 0)
 ZEND_END_ARG_INFO()
 
-#if HAVE_LIBGD15
 ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromstring, 0)
 	ZEND_ARG_INFO(0, image)
 ZEND_END_ARG_INFO()
-#endif
 
-#ifdef HAVE_GD_GIF_READ
 ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgif, 0)
 	ZEND_ARG_INFO(0, filename)
 ZEND_END_ARG_INFO()
-#endif
 
 #ifdef HAVE_GD_JPG
 ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromjpeg, 0)
@@ -360,29 +319,24 @@ ZEND_BEGIN_ARG_INFO(arginfo_imagecreatef
 ZEND_END_ARG_INFO()
 #endif
 
-#ifdef HAVE_GD_XBM
 ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromxbm, 0)
 	ZEND_ARG_INFO(0, filename)
 ZEND_END_ARG_INFO()
-#endif
 
-#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
+#if defined(HAVE_GD_XPM)
 ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromxpm, 0)
 	ZEND_ARG_INFO(0, filename)
 ZEND_END_ARG_INFO()
 #endif
 
-#ifdef HAVE_GD_WBMP
 ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromwbmp, 0)
 	ZEND_ARG_INFO(0, filename)
 ZEND_END_ARG_INFO()
-#endif
 
 ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgd, 0)
 	ZEND_ARG_INFO(0, filename)
 ZEND_END_ARG_INFO()
 
-#ifdef HAVE_GD_GD2
 ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgd2, 0)
 	ZEND_ARG_INFO(0, filename)
 ZEND_END_ARG_INFO()
@@ -394,22 +348,17 @@ ZEND_BEGIN_ARG_INFO(arginfo_imagecreatef
 	ZEND_ARG_INFO(0, width)
 	ZEND_ARG_INFO(0, height)
 ZEND_END_ARG_INFO()
-#endif
 
-#if HAVE_GD_BUNDLED
 ZEND_BEGIN_ARG_INFO_EX(arginfo_imagexbm, 0, 0, 2)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, filename)
 	ZEND_ARG_INFO(0, foreground)
 ZEND_END_ARG_INFO()
-#endif
 
-#ifdef HAVE_GD_GIF_CREATE
 ZEND_BEGIN_ARG_INFO_EX(arginfo_imagegif, 0, 0, 1)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, filename)
 ZEND_END_ARG_INFO()
-#endif
 
 #ifdef HAVE_GD_PNG
 ZEND_BEGIN_ARG_INFO_EX(arginfo_imagepng, 0, 0, 1)
@@ -433,27 +382,23 @@ ZEND_BEGIN_ARG_INFO_EX(arginfo_imagejpeg
 ZEND_END_ARG_INFO()
 #endif
 
-#ifdef HAVE_GD_WBMP
 ZEND_BEGIN_ARG_INFO_EX(arginfo_imagewbmp, 0, 0, 1)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, filename)
 	ZEND_ARG_INFO(0, foreground)
 ZEND_END_ARG_INFO()
-#endif
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_imagegd, 0, 0, 1)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, filename)
 ZEND_END_ARG_INFO()
 
-#ifdef HAVE_GD_GD2
 ZEND_BEGIN_ARG_INFO_EX(arginfo_imagegd2, 0, 0, 1)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, filename)
 	ZEND_ARG_INFO(0, chunk_size)
 	ZEND_ARG_INFO(0, type)
 ZEND_END_ARG_INFO()
-#endif
 
 ZEND_BEGIN_ARG_INFO(arginfo_imagedestroy, 0)
 	ZEND_ARG_INFO(0, im)
@@ -466,12 +411,10 @@ ZEND_BEGIN_ARG_INFO(arginfo_imagecoloral
 	ZEND_ARG_INFO(0, blue)
 ZEND_END_ARG_INFO()
 
-#if HAVE_LIBGD15
 ZEND_BEGIN_ARG_INFO(arginfo_imagepalettecopy, 0)
 	ZEND_ARG_INFO(0, dst)
 	ZEND_ARG_INFO(0, src)
 ZEND_END_ARG_INFO()
-#endif
 
 ZEND_BEGIN_ARG_INFO(arginfo_imagecolorat, 0)
 	ZEND_ARG_INFO(0, im)
@@ -486,14 +429,12 @@ ZEND_BEGIN_ARG_INFO(arginfo_imagecolorcl
 	ZEND_ARG_INFO(0, blue)
 ZEND_END_ARG_INFO()
 
-#if HAVE_COLORCLOSESTHWB
 ZEND_BEGIN_ARG_INFO(arginfo_imagecolorclosesthwb, 0)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, red)
 	ZEND_ARG_INFO(0, green)
 	ZEND_ARG_INFO(0, blue)
 ZEND_END_ARG_INFO()
-#endif
 
 ZEND_BEGIN_ARG_INFO(arginfo_imagecolordeallocate, 0)
 	ZEND_ARG_INFO(0, im)
@@ -695,7 +636,6 @@ ZEND_BEGIN_ARG_INFO(arginfo_imagecopy, 0
 	ZEND_ARG_INFO(0, src_h)
 ZEND_END_ARG_INFO()
 
-#if HAVE_LIBGD15
 ZEND_BEGIN_ARG_INFO(arginfo_imagecopymerge, 0)
 	ZEND_ARG_INFO(0, src_im)
 	ZEND_ARG_INFO(0, dst_im)
@@ -719,7 +659,6 @@ ZEND_BEGIN_ARG_INFO(arginfo_imagecopymer
 	ZEND_ARG_INFO(0, src_h)
 	ZEND_ARG_INFO(0, pct)
 ZEND_END_ARG_INFO()
-#endif
 
 ZEND_BEGIN_ARG_INFO(arginfo_imagecopyresized, 0)
 	ZEND_ARG_INFO(0, dst_im)
@@ -743,7 +682,7 @@ ZEND_BEGIN_ARG_INFO(arginfo_imagesy, 0)
 ZEND_END_ARG_INFO()
 
 #ifdef ENABLE_GD_TTF
-#if HAVE_LIBFREETYPE && HAVE_GD_STRINGFTEX
+#if HAVE_LIBFREETYPE
 ZEND_BEGIN_ARG_INFO_EX(arginfo_imageftbbox, 0, 0, 4)
 	ZEND_ARG_INFO(0, size)
 	ZEND_ARG_INFO(0, angle)
@@ -839,15 +778,13 @@ ZEND_BEGIN_ARG_INFO_EX(arginfo_imagepsbb
 ZEND_END_ARG_INFO()
 #endif
 
-#ifdef HAVE_GD_WBMP
 ZEND_BEGIN_ARG_INFO_EX(arginfo_image2wbmp, 0, 0, 1)
 	ZEND_ARG_INFO(0, im)
 	ZEND_ARG_INFO(0, filename)
 	ZEND_ARG_INFO(0, threshold)
 ZEND_END_ARG_INFO()
-#endif
 
-#if defined(HAVE_GD_JPG) && defined(HAVE_GD_WBMP)
+#if defined(HAVE_GD_JPG)
 ZEND_BEGIN_ARG_INFO(arginfo_jpeg2wbmp, 0)
 	ZEND_ARG_INFO(0, f_org)
 	ZEND_ARG_INFO(0, f_dest)
@@ -857,7 +794,7 @@ ZEND_BEGIN_ARG_INFO(arginfo_jpeg2wbmp, 0
 ZEND_END_ARG_INFO()
 #endif
 
-#if defined(HAVE_GD_PNG) && defined(HAVE_GD_WBMP)
+#if defined(HAVE_GD_PNG)
 ZEND_BEGIN_ARG_INFO(arginfo_png2wbmp, 0)
 	ZEND_ARG_INFO(0, f_org)
 	ZEND_ARG_INFO(0, f_dest)
@@ -883,16 +820,17 @@ ZEND_BEGIN_ARG_INFO(arginfo_imageconvolu
 	ZEND_ARG_INFO(0, offset)
 ZEND_END_ARG_INFO()
 
-#ifdef HAVE_GD_BUNDLED
-ZEND_BEGIN_ARG_INFO(arginfo_imageantialias, 0)
+ZEND_BEGIN_ARG_INFO(arginfo_imageflip, 0)
 	ZEND_ARG_INFO(0, im)
-	ZEND_ARG_INFO(0, on)
+	ZEND_ARG_INFO(0, mode)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO(arginfo_imageflip, 0)
+#ifdef HAVE_GD_BUNDLED
+ZEND_BEGIN_ARG_INFO(arginfo_imageantialias, 0)
 	ZEND_ARG_INFO(0, im)
-	ZEND_ARG_INFO(0, mode)
+	ZEND_ARG_INFO(0, on)
 ZEND_END_ARG_INFO()
+#endif
 
 ZEND_BEGIN_ARG_INFO(arginfo_imagecrop, 0)
 	ZEND_ARG_INFO(0, im)
@@ -934,8 +872,6 @@ ZEND_BEGIN_ARG_INFO(arginfo_imagesetinte
 	ZEND_ARG_INFO(0, method)
 ZEND_END_ARG_INFO()
 
-#endif
-
 /* }}} */
 
 /* {{{ gd_functions[]
@@ -948,14 +884,10 @@ const zend_function_entry gd_functions[]
 	PHP_FE(imagecharup,								arginfo_imagecharup)
 	PHP_FE(imagecolorat,							arginfo_imagecolorat)
 	PHP_FE(imagecolorallocate,						arginfo_imagecolorallocate)
-#if HAVE_LIBGD15
 	PHP_FE(imagepalettecopy,						arginfo_imagepalettecopy)
 	PHP_FE(imagecreatefromstring,					arginfo_imagecreatefromstring)
-#endif
 	PHP_FE(imagecolorclosest,						arginfo_imagecolorclosest)
-#if HAVE_COLORCLOSESTHWB
 	PHP_FE(imagecolorclosesthwb,					arginfo_imagecolorclosesthwb)
-#endif
 	PHP_FE(imagecolordeallocate,					arginfo_imagecolordeallocate)
 	PHP_FE(imagecolorresolve,						arginfo_imagecolorresolve)
 	PHP_FE(imagecolorexact,							arginfo_imagecolorexact)
@@ -964,10 +896,8 @@ const zend_function_entry gd_functions[]
 	PHP_FE(imagecolorstotal,						arginfo_imagecolorstotal)
 	PHP_FE(imagecolorsforindex,						arginfo_imagecolorsforindex)
 	PHP_FE(imagecopy,								arginfo_imagecopy)
-#if HAVE_LIBGD15
 	PHP_FE(imagecopymerge,							arginfo_imagecopymerge)
 	PHP_FE(imagecopymergegray,						arginfo_imagecopymergegray)
-#endif
 	PHP_FE(imagecopyresized,						arginfo_imagecopyresized)
 	PHP_FE(imagecreate,								arginfo_imagecreate)
 	PHP_FE(imagecreatetruecolor,					arginfo_imagecreatetruecolor)
@@ -991,10 +921,11 @@ const zend_function_entry gd_functions[]
 #endif
 
 	PHP_FE(imagerotate,     						arginfo_imagerotate)
+	PHP_FE(imageflip,								arginfo_imageflip)
 
 #ifdef HAVE_GD_BUNDLED
 	PHP_FE(imageantialias,							arginfo_imageantialias)
-	PHP_FE(imageflip,								arginfo_imageflip)
+#endif
 	PHP_FE(imagecrop,								arginfo_imagecrop)
 	PHP_FE(imagecropauto,							arginfo_imagecropauto)
 	PHP_FE(imagescale,								arginfo_imagescale)
@@ -1002,16 +933,8 @@ const zend_function_entry gd_functions[]
 	PHP_FE(imageaffinematrixconcat,					arginfo_imageaffinematrixconcat)
 	PHP_FE(imageaffinematrixget,					arginfo_imageaffinematrixget)
 	PHP_FE(imagesetinterpolation,                   arginfo_imagesetinterpolation)
-#endif
-
-#if HAVE_GD_IMAGESETTILE
 	PHP_FE(imagesettile,							arginfo_imagesettile)
-#endif
-
-#if HAVE_GD_IMAGESETBRUSH
 	PHP_FE(imagesetbrush,							arginfo_imagesetbrush)
-#endif
-
 	PHP_FE(imagesetstyle,							arginfo_imagesetstyle)
 
 #ifdef HAVE_GD_PNG
@@ -1020,45 +943,31 @@ const zend_function_entry gd_functions[]
 #ifdef HAVE_GD_WEBP
 	PHP_FE(imagecreatefromwebp,						arginfo_imagecreatefromwebp)
 #endif
-#ifdef HAVE_GD_GIF_READ
 	PHP_FE(imagecreatefromgif,						arginfo_imagecreatefromgif)
-#endif
 #ifdef HAVE_GD_JPG
 	PHP_FE(imagecreatefromjpeg,						arginfo_imagecreatefromjpeg)
 #endif
-#ifdef HAVE_GD_WBMP
 	PHP_FE(imagecreatefromwbmp,						arginfo_imagecreatefromwbmp)
-#endif
-#ifdef HAVE_GD_XBM
 	PHP_FE(imagecreatefromxbm,						arginfo_imagecreatefromxbm)
-#endif
-#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
+#if defined(HAVE_GD_XPM)
 	PHP_FE(imagecreatefromxpm,						arginfo_imagecreatefromxpm)
 #endif
 	PHP_FE(imagecreatefromgd,						arginfo_imagecreatefromgd)
-#ifdef HAVE_GD_GD2
 	PHP_FE(imagecreatefromgd2,						arginfo_imagecreatefromgd2)
 	PHP_FE(imagecreatefromgd2part,					arginfo_imagecreatefromgd2part)
-#endif
 #ifdef HAVE_GD_PNG
 	PHP_FE(imagepng,								arginfo_imagepng)
 #endif
 #ifdef HAVE_GD_WEBP
 	PHP_FE(imagewebp,								arginfo_imagewebp)
 #endif
-#ifdef HAVE_GD_GIF_CREATE
 	PHP_FE(imagegif,								arginfo_imagegif)
-#endif
 #ifdef HAVE_GD_JPG
 	PHP_FE(imagejpeg,								arginfo_imagejpeg)
 #endif
-#ifdef HAVE_GD_WBMP
 	PHP_FE(imagewbmp,                               arginfo_imagewbmp)
-#endif
 	PHP_FE(imagegd,									arginfo_imagegd)
-#ifdef HAVE_GD_GD2
 	PHP_FE(imagegd2,								arginfo_imagegd2)
-#endif
 
 	PHP_FE(imagedestroy,							arginfo_imagedestroy)
 	PHP_FE(imagegammacorrect,						arginfo_imagegammacorrect)
@@ -1083,7 +992,7 @@ const zend_function_entry gd_functions[]
 #ifdef ENABLE_GD_TTF
 	PHP_FE(imagettfbbox,							arginfo_imagettfbbox)
 	PHP_FE(imagettftext,							arginfo_imagettftext)
-#if HAVE_LIBFREETYPE && HAVE_GD_STRINGFTEX
+#if HAVE_GD_FREETYPE && HAVE_LIBFREETYPE
 	PHP_FE(imageftbbox,								arginfo_imageftbbox)
 	PHP_FE(imagefttext,								arginfo_imagefttext)
 #endif
@@ -1103,19 +1012,15 @@ const zend_function_entry gd_functions[]
 #endif
 	PHP_FE(imagetypes,								arginfo_imagetypes)
 
-#if defined(HAVE_GD_JPG) && defined(HAVE_GD_WBMP)
+#if defined(HAVE_GD_JPG)
 	PHP_FE(jpeg2wbmp,								arginfo_jpeg2wbmp)
 #endif
-#if defined(HAVE_GD_PNG) && defined(HAVE_GD_WBMP)
+#if defined(HAVE_GD_PNG)
 	PHP_FE(png2wbmp,								arginfo_png2wbmp)
 #endif
-#ifdef HAVE_GD_WBMP
 	PHP_FE(image2wbmp,								arginfo_image2wbmp)
-#endif
-#if HAVE_GD_BUNDLED
 	PHP_FE(imagelayereffect,						arginfo_imagelayereffect)
 	PHP_FE(imagexbm,                                arginfo_imagexbm)
-#endif
 
 	PHP_FE(imagecolormatch,							arginfo_imagecolormatch)
 
@@ -1132,13 +1037,13 @@ zend_module_entry gd_module_entry = {
 	"gd",
 	gd_functions,
 	PHP_MINIT(gd),
-#if HAVE_LIBT1 || HAVE_GD_FONTMUTEX
+#if HAVE_LIBT1
 	PHP_MSHUTDOWN(gd),
 #else
 	NULL,
 #endif
 	NULL,
-#if HAVE_GD_STRINGFT && (HAVE_LIBFREETYPE && (HAVE_GD_FONTCACHESHUTDOWN || HAVE_GD_FREEFONTCACHE))
+#if HAVE_GD_FREETYPE && HAVE_LIBFREETYPE
 	PHP_RSHUTDOWN(gd),
 #else
 	NULL,
@@ -1180,15 +1085,25 @@ static void php_free_gd_font(zend_rsrc_l
 }
 /* }}} */
 
+#ifndef HAVE_GD_BUNDLED
+/* {{{ php_gd_error_method
+ */
+void php_gd_error_method(int type, const char *format, va_list args)
+{
+	TSRMLS_FETCH();
+
+	php_verror(NULL, "", type, format, args TSRMLS_CC);
+}
+/* }}} */
+#endif
+
 /* {{{ PHP_MSHUTDOWN_FUNCTION
  */
-#if HAVE_LIBT1 || HAVE_GD_FONTMUTEX
+#if HAVE_LIBT1
 PHP_MSHUTDOWN_FUNCTION(gd)
 {
-#if HAVE_LIBT1
 	T1_CloseLib();
-#endif
-#if HAVE_GD_FONTMUTEX && HAVE_LIBFREETYPE
+#if HAVE_GD_BUNDLED && HAVE_LIBFREETYPE
 	gdFontCacheMutexShutdown();
 #endif
 	UNREGISTER_INI_ENTRIES();
@@ -1205,7 +1120,7 @@ PHP_MINIT_FUNCTION(gd)
 	le_gd = zend_register_list_destructors_ex(php_free_gd_image, NULL, "gd", module_number);
 	le_gd_font = zend_register_list_destructors_ex(php_free_gd_font, NULL, "gd font", module_number);
 
-#if HAVE_GD_FONTMUTEX && HAVE_LIBFREETYPE
+#if HAVE_GD_BUNDLED && HAVE_LIBFREETYPE
 	gdFontCacheMutexSetup();
 #endif
 #if HAVE_LIBT1
@@ -1215,7 +1130,9 @@ PHP_MINIT_FUNCTION(gd)
 	le_ps_font = zend_register_list_destructors_ex(php_free_ps_font, NULL, "gd PS font", module_number);
 	le_ps_enc = zend_register_list_destructors_ex(php_free_ps_enc, NULL, "gd PS encoding", module_number);
 #endif
-
+#ifndef HAVE_GD_BUNDLED
+	gdSetErrorMethod(php_gd_error_method);
+#endif
 	REGISTER_INI_ENTRIES();
 
 	REGISTER_LONG_CONSTANT("IMG_GIF", 1, CONST_CS | CONST_PERSISTENT);
@@ -1224,14 +1141,14 @@ PHP_MINIT_FUNCTION(gd)
 	REGISTER_LONG_CONSTANT("IMG_PNG", 4, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_WBMP", 8, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_XPM", 16, CONST_CS | CONST_PERSISTENT);
-#ifdef gdTiled
+
 	/* special colours for gd */
 	REGISTER_LONG_CONSTANT("IMG_COLOR_TILED", gdTiled, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_COLOR_STYLED", gdStyled, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_COLOR_BRUSHED", gdBrushed, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_COLOR_STYLEDBRUSHED", gdStyledBrushed, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_COLOR_TRANSPARENT", gdTransparent, CONST_CS | CONST_PERSISTENT);
-#endif
+
 	/* for imagefilledarc */
 	REGISTER_LONG_CONSTANT("IMG_ARC_ROUNDED", gdArc, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_ARC_PIE", gdPie, CONST_CS | CONST_PERSISTENT);
@@ -1239,23 +1156,16 @@ PHP_MINIT_FUNCTION(gd)
 	REGISTER_LONG_CONSTANT("IMG_ARC_NOFILL", gdNoFill, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_ARC_EDGED", gdEdged, CONST_CS | CONST_PERSISTENT);
 
-/* GD2 image format types */
-#ifdef GD2_FMT_RAW
+    /* GD2 image format types */
 	REGISTER_LONG_CONSTANT("IMG_GD2_RAW", GD2_FMT_RAW, CONST_CS | CONST_PERSISTENT);
-#endif
-#ifdef GD2_FMT_COMPRESSED
 	REGISTER_LONG_CONSTANT("IMG_GD2_COMPRESSED", GD2_FMT_COMPRESSED, CONST_CS | CONST_PERSISTENT);
-#endif
-#if HAVE_GD_BUNDLED
+	REGISTER_LONG_CONSTANT("IMG_FLIP_HORIZONTAL", GD_FLIP_HORINZONTAL, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("IMG_FLIP_VERTICAL", GD_FLIP_VERTICAL, CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("IMG_FLIP_BOTH", GD_FLIP_BOTH, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_EFFECT_REPLACE", gdEffectReplace, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_EFFECT_ALPHABLEND", gdEffectAlphaBlend, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_EFFECT_NORMAL", gdEffectNormal, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_EFFECT_OVERLAY", gdEffectOverlay, CONST_CS | CONST_PERSISTENT);
-	REGISTER_LONG_CONSTANT("GD_BUNDLED", 1, CONST_CS | CONST_PERSISTENT);
-
-	REGISTER_LONG_CONSTANT("IMG_FLIP_HORIZONTAL", GD_FLIP_HORINZONTAL, CONST_CS | CONST_PERSISTENT);
-	REGISTER_LONG_CONSTANT("IMG_FLIP_VERTICAL", GD_FLIP_VERTICAL, CONST_CS | CONST_PERSISTENT);
-	REGISTER_LONG_CONSTANT("IMG_FLIP_BOTH", GD_FLIP_BOTH, CONST_CS | CONST_PERSISTENT);
 
 	REGISTER_LONG_CONSTANT("IMG_CROP_DEFAULT", GD_CROP_DEFAULT, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_CROP_TRANSPARENT", GD_CROP_TRANSPARENT, CONST_CS | CONST_PERSISTENT);
@@ -1293,6 +1203,8 @@ PHP_MINIT_FUNCTION(gd)
 	REGISTER_LONG_CONSTANT("IMG_AFFINE_SHEAR_HORIZONTAL", GD_AFFINE_SHEAR_HORIZONTAL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("IMG_AFFINE_SHEAR_VERTICAL", GD_AFFINE_SHEAR_VERTICAL, CONST_CS | CONST_PERSISTENT);
 
+#if defined(HAVE_GD_BUNDLED)
+	REGISTER_LONG_CONSTANT("GD_BUNDLED", 1, CONST_CS | CONST_PERSISTENT);
 #else
 	REGISTER_LONG_CONSTANT("GD_BUNDLED", 0, CONST_CS | CONST_PERSISTENT);
 #endif
@@ -1346,27 +1258,19 @@ PHP_MINIT_FUNCTION(gd)
 
 /* {{{ PHP_RSHUTDOWN_FUNCTION
  */
-#if HAVE_GD_STRINGFT && (HAVE_LIBFREETYPE && (HAVE_GD_FONTCACHESHUTDOWN || HAVE_GD_FREEFONTCACHE))
+#if HAVE_GD_FREETYPE && HAVE_LIBFREETYPE
 PHP_RSHUTDOWN_FUNCTION(gd)
 {
-#if HAVE_GD_FONTCACHESHUTDOWN
 	gdFontCacheShutdown();
-#else
-	gdFreeFontCache();
-#endif
 	return SUCCESS;
 }
 #endif
 /* }}} */
 
-#if HAVE_GD_BUNDLED
+#if defined(HAVE_GD_BUNDLED)
 #define PHP_GD_VERSION_STRING "bundled (2.1.0 compatible)"
 #else
-# ifdef GD_VERSION_STRING
-#  define PHP_GD_VERSION_STRING GD_VERSION_STRING
-# else
-#  define PHP_GD_VERSION_STRING "2.0"
-# endif
+# define PHP_GD_VERSION_STRING GD_VERSION_STRING
 #endif
 
 /* {{{ PHP_MINFO_FUNCTION
@@ -1405,20 +1309,13 @@ PHP_MINFO_FUNCTION(gd)
 	php_info_print_table_row(2, "T1Lib Support", "enabled");
 #endif
 
-/* this next part is stupid ... if I knew better, I'd put them all on one row (cmv) */
-
-#ifdef HAVE_GD_GIF_READ
 	php_info_print_table_row(2, "GIF Read Support", "enabled");
-#endif
-#ifdef HAVE_GD_GIF_CREATE
 	php_info_print_table_row(2, "GIF Create Support", "enabled");
-#endif
+
 #ifdef HAVE_GD_JPG
 	{
-		char tmp[12];
-		snprintf(tmp, sizeof(tmp), "%s", gdJpegGetVersionString());
 		php_info_print_table_row(2, "JPEG Support", "enabled");
-		php_info_print_table_row(2, "libJPEG Version", tmp);
+		php_info_print_table_row(2, "libJPEG Version", gdJpegGetVersionString());
 	}
 #endif
 
@@ -1426,10 +1323,8 @@ PHP_MINFO_FUNCTION(gd)
 	php_info_print_table_row(2, "PNG Support", "enabled");
 	php_info_print_table_row(2, "libPNG Version", gdPngGetVersionString());
 #endif
-#ifdef HAVE_GD_WBMP
 	php_info_print_table_row(2, "WBMP Support", "enabled");
-#endif
-#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
+#if defined(HAVE_GD_XPM)
 	php_info_print_table_row(2, "XPM Support", "enabled");
 	{
 		char tmp[12];
@@ -1437,10 +1332,8 @@ PHP_MINFO_FUNCTION(gd)
 		php_info_print_table_row(2, "libXpm Version", tmp);
 	}
 #endif
-#ifdef HAVE_GD_XBM
 	php_info_print_table_row(2, "XBM Support", "enabled");
-#endif
-#if defined(USE_GD_JISX0208) && defined(HAVE_GD_BUNDLED)
+#if defined(USE_GD_JISX0208)
 	php_info_print_table_row(2, "JIS-mapped Japanese Font Support", "enabled");
 #endif
 #ifdef HAVE_GD_WEBP
@@ -1479,16 +1372,8 @@ PHP_FUNCTION(gd_info)
 #else
 	add_assoc_bool(return_value, "T1Lib Support", 0);
 #endif
-#ifdef HAVE_GD_GIF_READ
 	add_assoc_bool(return_value, "GIF Read Support", 1);
-#else
-	add_assoc_bool(return_value, "GIF Read Support", 0);
-#endif
-#ifdef HAVE_GD_GIF_CREATE
 	add_assoc_bool(return_value, "GIF Create Support", 1);
-#else
-	add_assoc_bool(return_value, "GIF Create Support", 0);
-#endif
 #ifdef HAVE_GD_JPG
 	add_assoc_bool(return_value, "JPEG Support", 1);
 #else
@@ -1499,22 +1384,14 @@ PHP_FUNCTION(gd_info)
 #else
 	add_assoc_bool(return_value, "PNG Support", 0);
 #endif
-#ifdef HAVE_GD_WBMP
 	add_assoc_bool(return_value, "WBMP Support", 1);
-#else
-	add_assoc_bool(return_value, "WBMP Support", 0);
-#endif
-#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
+#if defined(HAVE_GD_XPM)
 	add_assoc_bool(return_value, "XPM Support", 1);
 #else
 	add_assoc_bool(return_value, "XPM Support", 0);
 #endif
-#ifdef HAVE_GD_XBM
 	add_assoc_bool(return_value, "XBM Support", 1);
-#else
-	add_assoc_bool(return_value, "XBM Support", 0);
-#endif
-#if defined(USE_GD_JISX0208) && defined(HAVE_GD_BUNDLED)
+#if defined(USE_GD_JISX0208)
 	add_assoc_bool(return_value, "JIS-mapped Japanese Font Support", 1);
 #else
 	add_assoc_bool(return_value, "JIS-mapped Japanese Font Support", 0);
@@ -1529,62 +1406,6 @@ PHP_GD_API int phpi_get_le_gd(void)
 }
 /* }}} */
 
-#ifndef HAVE_GDIMAGECOLORRESOLVE
-
-/* {{{ gdImageColorResolve
- */
-/********************************************************************/
-/* gdImageColorResolve is a replacement for the old fragment:       */
-/*                                                                  */
-/*      if ((color=gdImageColorExact(im,R,G,B)) < 0)                */
-/*        if ((color=gdImageColorAllocate(im,R,G,B)) < 0)           */
-/*          color=gdImageColorClosest(im,R,G,B);                    */
-/*                                                                  */
-/* in a single function                                             */
-
-int gdImageColorResolve(gdImagePtr im, int r, int g, int b)
-{
-	int c;
-	int ct = -1;
-	int op = -1;
-	long rd, gd, bd, dist;
-	long mindist = 3*255*255;  /* init to max poss dist */
-
-	for (c = 0; c < im->colorsTotal; c++) {
-		if (im->open[c]) {
-			op = c;             /* Save open slot */
-			continue;           /* Color not in use */
-		}
-		rd = (long) (im->red  [c] - r);
-		gd = (long) (im->green[c] - g);
-		bd = (long) (im->blue [c] - b);
-		dist = rd * rd + gd * gd + bd * bd;
-		if (dist < mindist) {
-			if (dist == 0) {
-				return c;       /* Return exact match color */
-			}
-			mindist = dist;
-			ct = c;
-		}
-	}
-	/* no exact match.  We now know closest, but first try to allocate exact */
-	if (op == -1) {
-		op = im->colorsTotal;
-		if (op == gdMaxColors) {    /* No room for more colors */
-			return ct;          /* Return closest available color */
-		}
-		im->colorsTotal++;
-	}
-	im->red  [op] = r;
-	im->green[op] = g;
-	im->blue [op] = b;
-	im->open [op] = 0;
-	return op;                  /* Return newly allocated color */
-}
-/* }}} */
-
-#endif
-
 #define FLIPWORD(a) (((a & 0xff000000) >> 24) | ((a & 0x00ff0000) >> 8) | ((a & 0x0000ff00) << 8) | ((a & 0x000000ff) << 24))
 
 /* {{{ proto int imageloadfont(string filename)
@@ -1647,13 +1468,9 @@ PHP_FUNCTION(imageloadfont)
 		body_size = font->w * font->h * font->nchars;
 	}
 
-	if (overflow2(font->nchars, font->h)) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error reading font, invalid font header");
-		efree(font);
-		php_stream_close(stream);
-		RETURN_FALSE;
-	}
-	if (overflow2(font->nchars * font->h, font->w )) {
+	if ((font->nchars <= 0 || font->h <= 0 || font->w <= 0 ) || \
+		(font->nchars > INT_MAX / font->h) || \
+		(font->nchars * font->h > INT_MAX / font->w)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error reading font, invalid font header");
 		efree(font);
 		php_stream_close(stream);
@@ -1976,7 +1793,6 @@ PHP_FUNCTION(imagesavealpha)
 }
 /* }}} */
 
-#if HAVE_GD_BUNDLED
 /* {{{ proto bool imagelayereffect(resource im, int effect)
    Set the alpha blending flag to use the bundled libgd layering effects */
 PHP_FUNCTION(imagelayereffect)
@@ -1995,7 +1811,6 @@ PHP_FUNCTION(imagelayereffect)
 	RETURN_TRUE;
 }
 /* }}} */
-#endif
 
 /* {{{ proto int imagecolorallocatealpha(resource im, int red, int green, int blue, int alpha)
    Allocate a color with an alpha level.  Works for true color and palette based images */
@@ -2280,7 +2095,6 @@ PHP_FUNCTION(imagerotate)
 }
 /* }}} */
 
-#if HAVE_GD_IMAGESETTILE
 /* {{{ proto bool imagesettile(resource image, resource tile)
    Set the tile image to $tile when filling $image with the "IMG_COLOR_TILED" color */
 PHP_FUNCTION(imagesettile)
@@ -2300,9 +2114,7 @@ PHP_FUNCTION(imagesettile)
 	RETURN_TRUE;
 }
 /* }}} */
-#endif
 
-#if HAVE_GD_IMAGESETBRUSH
 /* {{{ proto bool imagesetbrush(resource image, resource brush)
    Set the brush image to $brush when filling $image with the "IMG_COLOR_BRUSHED" color */
 PHP_FUNCTION(imagesetbrush)
@@ -2322,7 +2134,6 @@ PHP_FUNCTION(imagesetbrush)
 	RETURN_TRUE;
 }
 /* }}} */
-#endif
 
 /* {{{ proto resource imagecreate(int x_size, int y_size)
    Create a new image */
@@ -2355,19 +2166,15 @@ PHP_FUNCTION(imagecreate)
 PHP_FUNCTION(imagetypes)
 {
 	int ret=0;
-#ifdef HAVE_GD_GIF_CREATE
 	ret = 1;
-#endif
 #ifdef HAVE_GD_JPG
 	ret |= 2;
 #endif
 #ifdef HAVE_GD_PNG
 	ret |= 4;
 #endif
-#ifdef HAVE_GD_WBMP
 	ret |= 8;
-#endif
-#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
+#if defined(HAVE_GD_XPM)
 	ret |= 16;
 #endif
 
@@ -2379,13 +2186,31 @@ PHP_FUNCTION(imagetypes)
 }
 /* }}} */
 
+/* {{{ _php_ctx_getmbi
+ */
+
+static int _php_ctx_getmbi(gdIOCtx *ctx)
+{
+	int i, mbi = 0;
+
+	do {
+		i = (ctx->getC)(ctx);
+		if (i < 0) {
+			return -1;
+		}
+		mbi = (mbi << 7) | (i & 0x7f);
+	} while (i & 0x80);
+
+	return mbi;
+}
+/* }}} */
+
 /* {{{ _php_image_type
  */
 static const char php_sig_gd2[3] = {'g', 'd', '2'};
 
 static int _php_image_type (char data[8])
 {
-#ifdef HAVE_LIBGD15
 	/* Based on ext/standard/image.c */
 
 	if (data == NULL) {
@@ -2403,34 +2228,22 @@ static int _php_image_type (char data[8]
 	} else if (!memcmp(data, php_sig_gif, 3)) {
 		return PHP_GDIMG_TYPE_GIF;
 	}
-#ifdef HAVE_GD_WBMP
 	else {
 		gdIOCtx *io_ctx;
 		io_ctx = gdNewDynamicCtxEx(8, data, 0);
 		if (io_ctx) {
-			if (getmbi((int(*)(void *)) io_ctx->getC, io_ctx) == 0 && skipheader((int(*)(void *)) io_ctx->getC, io_ctx) == 0 ) {
-#if HAVE_LIBGD204
+			if (_php_ctx_getmbi(io_ctx) == 0 && _php_ctx_getmbi(io_ctx) >= 0) {
 				io_ctx->gd_free(io_ctx);
-#else
-				io_ctx->free(io_ctx);
-#endif
 				return PHP_GDIMG_TYPE_WBM;
 			} else {
-#if HAVE_LIBGD204
 				io_ctx->gd_free(io_ctx);
-#else
-				io_ctx->free(io_ctx);
-#endif
 			}
 		}
 	}
-#endif
 	return -1;
-#endif
 }
 /* }}} */
 
-#ifdef HAVE_LIBGD15
 /* {{{ _php_image_create_from_string
  */
 gdImagePtr _php_image_create_from_string(zval **data, char *tn, gdImagePtr (*ioctx_func_p)() TSRMLS_DC)
@@ -2447,19 +2260,11 @@ gdImagePtr _php_image_create_from_string
 	im = (*ioctx_func_p)(io_ctx);
 	if (!im) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Passed data is not in '%s' format", tn);
-#if HAVE_LIBGD204
 		io_ctx->gd_free(io_ctx);
-#else
-		io_ctx->free(io_ctx);
-#endif
 		return NULL;
 	}
 
-#if HAVE_LIBGD204
 	io_ctx->gd_free(io_ctx);
-#else
-	io_ctx->free(io_ctx);
-#endif
 
 	return im;
 }
@@ -2508,30 +2313,15 @@ PHP_FUNCTION(imagecreatefromstring)
 			break;
 
 		case PHP_GDIMG_TYPE_GIF:
-#ifdef HAVE_GD_GIF_READ
 			im = _php_image_create_from_string(data, "GIF", gdImageCreateFromGifCtx TSRMLS_CC);
-#else
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "No GIF support in this PHP build");
-			RETURN_FALSE;
-#endif
 			break;
 
 		case PHP_GDIMG_TYPE_WBM:
-#ifdef HAVE_GD_WBMP
 			im = _php_image_create_from_string(data, "WBMP", gdImageCreateFromWBMPCtx TSRMLS_CC);
-#else
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "No WBMP support in this PHP build");
-			RETURN_FALSE;
-#endif
 			break;
 
 		case PHP_GDIMG_TYPE_GD2:
-#ifdef HAVE_GD_GD2
 			im = _php_image_create_from_string(data, "GD2", gdImageCreateFromGd2Ctx TSRMLS_CC);
-#else
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "No GD2 support in this PHP build");
-			RETURN_FALSE;
-#endif
 			break;
 
 		default:
@@ -2547,7 +2337,6 @@ PHP_FUNCTION(imagecreatefromstring)
 	ZEND_REGISTER_RESOURCE(return_value, im, le_gd);
 }
 /* }}} */
-#endif
 
 /* {{{ _php_image_create_from
  */
@@ -2559,9 +2348,8 @@ static void _php_image_create_from(INTER
 	gdImagePtr im = NULL;
 	php_stream *stream;
 	FILE * fp = NULL;
-#ifdef HAVE_GD_JPG
 	long ignore_warning;
-#endif
+
 	if (image_type == PHP_GDIMG_TYPE_GD2PART) {
 		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sllll", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
 			return;
@@ -2581,9 +2369,7 @@ static void _php_image_create_from(INTER
 		RETURN_FALSE;
 	}
 
-#ifndef USE_GD_IOCTX
 	ioctx_func_p = NULL; /* don't allow sockets without IOCtx */
-#endif
 
 	if (image_type == PHP_GDIMG_TYPE_WEBP) {
 		size_t buff_size;
@@ -2608,7 +2394,6 @@ static void _php_image_create_from(INTER
 			goto out_err;
 		}
 	} else if (ioctx_func_p) {
-#ifdef USE_GD_IOCTX
 		/* we can create an io context */
 		gdIOCtx* io_ctx;
 		size_t buff_size;
@@ -2634,13 +2419,8 @@ static void _php_image_create_from(INTER
 		} else {
 			im = (*ioctx_func_p)(io_ctx);
 		}
-#if HAVE_LIBGD204
 		io_ctx->gd_free(io_ctx);
-#else
-		io_ctx->free(io_ctx);
-#endif
 		pefree(buff, 1);
-#endif
 	}
 	else {
 		/* try and force the stream to be FILE* */
@@ -2654,7 +2434,7 @@ static void _php_image_create_from(INTER
 			case PHP_GDIMG_TYPE_GD2PART:
 				im = (*func_p)(fp, srcx, srcy, width, height);
 				break;
-#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
+#if defined(HAVE_GD_XPM)
 			case PHP_GDIMG_TYPE_XPM:
 				im = gdImageCreateFromXpm(file);
 				break;
@@ -2663,11 +2443,7 @@ static void _php_image_create_from(INTER
 #ifdef HAVE_GD_JPG
 			case PHP_GDIMG_TYPE_JPG:
 				ignore_warning = INI_INT("gd.jpeg_ignore_warning");
-#ifdef HAVE_GD_BUNDLED
-				im = gdImageCreateFromJpeg(fp, ignore_warning);
-#else
-				im = gdImageCreateFromJpeg(fp);
-#endif
+				im = gdImageCreateFromJpegEx(fp, ignore_warning);
 			break;
 #endif
 
@@ -2694,7 +2470,6 @@ out_err:
 }
 /* }}} */
 
-#ifdef HAVE_GD_GIF_READ
 /* {{{ proto resource imagecreatefromgif(string filename)
    Create a new image from GIF file or URL */
 PHP_FUNCTION(imagecreatefromgif)
@@ -2702,7 +2477,6 @@ PHP_FUNCTION(imagecreatefromgif)
 	_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, "GIF", gdImageCreateFromGif, gdImageCreateFromGifCtx);
 }
 /* }}} */
-#endif /* HAVE_GD_GIF_READ */
 
 #ifdef HAVE_GD_JPG
 /* {{{ proto resource imagecreatefromjpeg(string filename)
@@ -2734,7 +2508,6 @@ PHP_FUNCTION(imagecreatefromwebp)
 /* }}} */
 #endif /* HAVE_GD_VPX */
 
-#ifdef HAVE_GD_XBM
 /* {{{ proto resource imagecreatefromxbm(string filename)
    Create a new image from XBM file or URL */
 PHP_FUNCTION(imagecreatefromxbm)
@@ -2742,9 +2515,8 @@ PHP_FUNCTION(imagecreatefromxbm)
 	_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, "XBM", gdImageCreateFromXbm, NULL);
 }
 /* }}} */
-#endif /* HAVE_GD_XBM */
 
-#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
+#if defined(HAVE_GD_XPM)
 /* {{{ proto resource imagecreatefromxpm(string filename)
    Create a new image from XPM file or URL */
 PHP_FUNCTION(imagecreatefromxpm)
@@ -2754,7 +2526,6 @@ PHP_FUNCTION(imagecreatefromxpm)
 /* }}} */
 #endif
 
-#ifdef HAVE_GD_WBMP
 /* {{{ proto resource imagecreatefromwbmp(string filename)
    Create a new image from WBMP file or URL */
 PHP_FUNCTION(imagecreatefromwbmp)
@@ -2762,7 +2533,6 @@ PHP_FUNCTION(imagecreatefromwbmp)
 	_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, "WBMP", gdImageCreateFromWBMP, gdImageCreateFromWBMPCtx);
 }
 /* }}} */
-#endif /* HAVE_GD_WBMP */
 
 /* {{{ proto resource imagecreatefromgd(string filename)
    Create a new image from GD file or URL */
@@ -2772,7 +2542,6 @@ PHP_FUNCTION(imagecreatefromgd)
 }
 /* }}} */
 
-#ifdef HAVE_GD_GD2
 /* {{{ proto resource imagecreatefromgd2(string filename)
    Create a new image from GD2 file or URL */
 PHP_FUNCTION(imagecreatefromgd2)
@@ -2788,7 +2557,6 @@ PHP_FUNCTION(imagecreatefromgd2part)
 	_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2PART, "GD2", gdImageCreateFromGd2Part, gdImageCreateFromGd2PartCtx);
 }
 /* }}} */
-#endif /* HAVE_GD_GD2 */
 
 /* {{{ _php_image_output
  */
@@ -2833,7 +2601,6 @@ static void _php_image_output(INTERNAL_F
 		}
 
 		switch (image_type) {
-#ifdef HAVE_GD_WBMP
 			case PHP_GDIMG_CONVERT_WBM:
 				if (q == -1) {
 					q = 0;
@@ -2843,7 +2610,6 @@ static void _php_image_output(INTERNAL_F
 				}
 				gdImageWBMP(im, q, fp);
 				break;
-#endif
 			case PHP_GDIMG_TYPE_JPG:
 				(*func_p)(im, fp, q);
 				break;
@@ -2859,14 +2625,12 @@ static void _php_image_output(INTERNAL_F
 				}
 				(*func_p)(im, fp);
 				break;
-#ifdef HAVE_GD_GD2
 			case PHP_GDIMG_TYPE_GD2:
 				if (q == -1) {
 					q = 128;
 				}
 				(*func_p)(im, fp, q, t);
 				break;
-#endif
 			default:
 				if (q == -1) {
 					q = 128;
@@ -2889,7 +2653,6 @@ static void _php_image_output(INTERNAL_F
 		}
 
 		switch (image_type) {
-#ifdef HAVE_GD_WBMP
 			case PHP_GDIMG_CONVERT_WBM:
  				if (q == -1) {
   					q = 0;
@@ -2899,7 +2662,6 @@ static void _php_image_output(INTERNAL_F
   				}
 				gdImageWBMP(im, q, tmp);
 				break;
-#endif
 			case PHP_GDIMG_TYPE_JPG:
 				(*func_p)(im, tmp, q);
 				break;
@@ -2917,14 +2679,12 @@ static void _php_image_output(INTERNAL_F
 				}
 				(*func_p)(im, tmp);
 				break;
-#ifdef HAVE_GD_GD2
 			case PHP_GDIMG_TYPE_GD2:
 				if (q == -1) {
 					q = 128;
 				}
 				(*func_p)(im, tmp, q, t);
 				break;
-#endif
 			default:
 				(*func_p)(im, tmp);
 				break;
@@ -2952,15 +2712,12 @@ static void _php_image_output(INTERNAL_F
 
 /* {{{ proto int imagexbm(int im, string filename [, int foreground])
    Output XBM image to browser or file */
-#if HAVE_GD_BUNDLED
 PHP_FUNCTION(imagexbm)
 {
 	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, "XBM", gdImageXbmCtx);
 }
-#endif
 /* }}} */
 
-#ifdef HAVE_GD_GIF_CREATE
 /* {{{ proto bool imagegif(resource im [, string filename])
    Output GIF image to browser or file */
 PHP_FUNCTION(imagegif)
@@ -2968,7 +2725,6 @@ PHP_FUNCTION(imagegif)
 	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, "GIF", gdImageGifCtx);
 }
 /* }}} */
-#endif /* HAVE_GD_GIF_CREATE */
 
 #ifdef HAVE_GD_PNG
 /* {{{ proto bool imagepng(resource im [, string filename])
@@ -3002,7 +2758,6 @@ PHP_FUNCTION(imagejpeg)
 /* }}} */
 #endif /* HAVE_GD_JPG */
 
-#ifdef HAVE_GD_WBMP
 /* {{{ proto bool imagewbmp(resource im [, string filename, [, int foreground]])
    Output WBMP image to browser or file */
 PHP_FUNCTION(imagewbmp)
@@ -3010,7 +2765,6 @@ PHP_FUNCTION(imagewbmp)
 	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, "WBMP", gdImageWBMPCtx);
 }
 /* }}} */
-#endif /* HAVE_GD_WBMP */
 
 /* {{{ proto bool imagegd(resource im [, string filename])
    Output GD image to browser or file */
@@ -3020,7 +2774,6 @@ PHP_FUNCTION(imagegd)
 }
 /* }}} */
 
-#ifdef HAVE_GD_GD2
 /* {{{ proto bool imagegd2(resource im [, string filename, [, int chunk_size, [, int type]]])
    Output GD2 image to browser or file */
 PHP_FUNCTION(imagegd2)
@@ -3028,7 +2781,6 @@ PHP_FUNCTION(imagegd2)
 	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, "GD2", gdImageGd2);
 }
 /* }}} */
-#endif /* HAVE_GD_GD2 */
 
 /* {{{ proto bool imagedestroy(resource im)
    Destroy an image */
@@ -3073,7 +2825,6 @@ PHP_FUNCTION(imagecolorallocate)
 }
 /* }}} */
 
-#if HAVE_LIBGD15
 /* {{{ proto void imagepalettecopy(resource dst, resource src)
    Copy the palette from the src image onto the dst image */
 PHP_FUNCTION(imagepalettecopy)
@@ -3091,7 +2842,6 @@ PHP_FUNCTION(imagepalettecopy)
 	gdImagePaletteCopy(dst, src);
 }
 /* }}} */
-#endif
 
 /* {{{ proto int imagecolorat(resource im, int x, int y)
    Get the index of the color of a pixel */
@@ -3143,7 +2893,6 @@ PHP_FUNCTION(imagecolorclosest)
 }
 /* }}} */
 
-#if HAVE_COLORCLOSESTHWB
 /* {{{ proto int imagecolorclosesthwb(resource im, int red, int green, int blue)
    Get the index of the color which has the hue, white and blackness nearest to the given color */
 PHP_FUNCTION(imagecolorclosesthwb)
@@ -3161,7 +2910,6 @@ PHP_FUNCTION(imagecolorclosesthwb)
 	RETURN_LONG(gdImageColorClosestHWB(im, red, green, blue));
 }
 /* }}} */
-#endif
 
 /* {{{ proto bool imagecolordeallocate(resource im, int index)
    De-allocate a color for an image */
@@ -3883,7 +3631,6 @@ PHP_FUNCTION(imagecopy)
 }
 /* }}} */
 
-#if HAVE_LIBGD15
 /* {{{ proto bool imagecopymerge(resource src_im, resource dst_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h, int pct)
    Merge one part of an image with another */
 PHP_FUNCTION(imagecopymerge)
@@ -3941,7 +3688,6 @@ PHP_FUNCTION(imagecopymergegray)
 	RETURN_TRUE;
 }
 /* }}} */
-#endif
 
 /* {{{ proto bool imagecopyresized(resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int dst_w, int dst_h, int src_w, int src_h)
    Copy and resize part of an image */
@@ -4019,7 +3765,7 @@ PHP_FUNCTION(imagesy)
 
 #ifdef ENABLE_GD_TTF
 
-#if  HAVE_LIBFREETYPE && HAVE_GD_STRINGFTEX
+#if HAVE_GD_FREETYPE && HAVE_LIBFREETYPE
 /* {{{ proto array imageftbbox(float size, float angle, string font_file, string text [, array extrainfo])
    Give the bounding box of a text using fonts via freetype2 */
 PHP_FUNCTION(imageftbbox)
@@ -4035,7 +3781,7 @@ PHP_FUNCTION(imagefttext)
 	php_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_DRAW, 1);
 }
 /* }}} */
-#endif
+#endif /* HAVE_GD_FREETYPE && HAVE_LIBFREETYPE */
 
 /* {{{ proto array imagettfbbox(float size, float angle, string font_file, string text)
    Give the bounding box of a text using TrueType fonts */
@@ -4065,13 +3811,7 @@ static void php_imagettftext_common(INTE
 	char *str = NULL, *fontname = NULL;
 	char *error = NULL;
 	int argc = ZEND_NUM_ARGS();
-#if HAVE_GD_STRINGFTEX
 	gdFTStringExtra strex = {0};
-#endif
-
-#if !HAVE_GD_STRINGFTEX
-	assert(!extended);
-#endif
 
 	if (mode == TTFTEXT_BBOX) {
 		if (argc < 4 || argc > ((extended) ? 5 : 4)) {
@@ -4091,7 +3831,6 @@ static void php_imagettftext_common(INTE
 	/* convert angle to radians */
 	angle = angle * (M_PI/180);
 
-#if HAVE_GD_STRINGFTEX
 	if (extended && EXT) {	/* parse extended info */
 		HashPosition pos;
 
@@ -4118,7 +3857,6 @@ static void php_imagettftext_common(INTE
 
 		} while (zend_hash_move_forward_ex(HASH_OF(EXT), &pos) == SUCCESS);
 	}
-#endif
 
 #ifdef VIRTUAL_DIR
 	{
@@ -4128,25 +3866,18 @@ static void php_imagettftext_common(INTE
 			fontname = NULL;
 		}
 	}
-#endif
+#endif /* VIRTUAL_DIR */
 
 	PHP_GD_CHECK_OPEN_BASEDIR(fontname, "Invalid font filename");
 	
-#ifdef USE_GD_IMGSTRTTF
-# if HAVE_GD_STRINGFTEX
+#ifdef HAVE_GD_FREETYPE
 	if (extended) {
 		error = gdImageStringFTEx(im, brect, col, fontname, ptsize, angle, x, y, str, &strex);
 	}
 	else
-# endif
-
-# if HAVE_GD_STRINGFT
-	error = gdImageStringFT(im, brect, col, fontname, ptsize, angle, x, y, str);
-# elif HAVE_GD_STRINGTTF
-	error = gdImageStringTTF(im, brect, col, fontname, ptsize, angle, x, y, str);
-# endif
+		error = gdImageStringFT(im, brect, col, fontname, ptsize, angle, x, y, str);
 
-#endif
+#endif /* HAVE_GD_FREETYPE */
 
 	if (error) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s", error);
@@ -4617,7 +4348,6 @@ PHP_FUNCTION(imagepsbbox)
 /* }}} */
 #endif
 
-#ifdef HAVE_GD_WBMP
 /* {{{ proto bool image2wbmp(resource im [, string filename [, int threshold]])
    Output WBMP image to browser or file */
 PHP_FUNCTION(image2wbmp)
@@ -4625,9 +4355,8 @@ PHP_FUNCTION(image2wbmp)
 	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_CONVERT_WBM, "WBMP", _php_image_bw_convert);
 }
 /* }}} */
-#endif /* HAVE_GD_WBMP */
 
-#if defined(HAVE_GD_JPG) && defined(HAVE_GD_WBMP)
+#if defined(HAVE_GD_JPG)
 /* {{{ proto bool jpeg2wbmp (string f_org, string f_dest, int d_height, int d_width, int threshold)
    Convert JPEG image to WBMP image */
 PHP_FUNCTION(jpeg2wbmp)
@@ -4637,7 +4366,7 @@ PHP_FUNCTION(jpeg2wbmp)
 /* }}} */
 #endif
 
-#if defined(HAVE_GD_PNG) && defined(HAVE_GD_WBMP)
+#if defined(HAVE_GD_PNG)
 /* {{{ proto bool png2wbmp (string f_org, string f_dest, int d_height, int d_width, int threshold)
    Convert PNG image to WBMP image */
 PHP_FUNCTION(png2wbmp)
@@ -4647,7 +4376,6 @@ PHP_FUNCTION(png2wbmp)
 /* }}} */
 #endif
 
-#ifdef HAVE_GD_WBMP
 /* {{{ _php_image_bw_convert
  * It converts a gd Image to bw using a threshold value */
 static void _php_image_bw_convert(gdImagePtr im_org, gdIOCtx *out, int threshold)
@@ -4694,11 +4422,7 @@ static void _php_image_bw_convert(gdImag
 			gdImageSetPixel (im_dest, x, y, color);
 		}
 	}
-#ifdef USE_GD_IOCTX
 	gdImageWBMPCtx (im_dest, black, out);
-#else
-	gdImageWBMP (im_dest, black, out);
-#endif
 
 }
 /* }}} */
@@ -4722,9 +4446,7 @@ static void _php_image_convert(INTERNAL_
 	int int_threshold;
 	int x, y;
 	float x_ratio, y_ratio;
-#ifdef HAVE_GD_JPG
     long ignore_warning;
-#endif
 	
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "pplll", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {
 		return;
@@ -4763,7 +4485,6 @@ static void _php_image_convert(INTERNAL_
 	}
 
 	switch (image_type) {
-#ifdef HAVE_GD_GIF_READ
 		case PHP_GDIMG_TYPE_GIF:
 			im_org = gdImageCreateFromGif(org);
 			if (im_org == NULL) {
@@ -4771,16 +4492,11 @@ static void _php_image_convert(INTERNAL_
 				RETURN_FALSE;
 			}
 			break;
-#endif /* HAVE_GD_GIF_READ */
 
 #ifdef HAVE_GD_JPG
 		case PHP_GDIMG_TYPE_JPG:
 			ignore_warning = INI_INT("gd.jpeg_ignore_warning");
-#ifdef HAVE_GD_BUNDLED
-			im_org = gdImageCreateFromJpeg(org, ignore_warning);
-#else
-			im_org = gdImageCreateFromJpeg(org);
-#endif
+			im_org = gdImageCreateFromJpegEx(org, ignore_warning);
 			if (im_org == NULL) {
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open '%s' Not a valid JPEG file", fn_dest);
 				RETURN_FALSE;
@@ -4788,7 +4504,6 @@ static void _php_image_convert(INTERNAL_
 			break;
 #endif /* HAVE_GD_JPG */
 
-
 #ifdef HAVE_GD_PNG
 		case PHP_GDIMG_TYPE_PNG:
 			im_org = gdImageCreateFromPng(org);
@@ -4889,9 +4604,6 @@ static void _php_image_convert(INTERNAL_
 	RETURN_TRUE;
 }
 /* }}} */
-#endif /* HAVE_GD_WBMP */
-
-#endif	/* HAVE_LIBGD */
 
 /* Section Filters */
 #define PHP_GD_SINGLE_RES	\
@@ -5189,26 +4901,6 @@ PHP_FUNCTION(imageconvolution)
 /* }}} */
 /* End section: Filters */
 
-#ifdef HAVE_GD_BUNDLED
-/* {{{ proto bool imageantialias(resource im, bool on)
-   Should antialiased functions used or not*/
-PHP_FUNCTION(imageantialias)
-{
-	zval *IM;
-	zend_bool alias;
-	gdImagePtr im;
-
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rb", &IM, &alias) == FAILURE) {
-		return;
-	}
-
-	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
-	gdImageAntialias(im, alias);
-	RETURN_TRUE;
-}
-/* }}} */
-
-
 /* {{{ proto void imageflip(resource im, int mode)
    Flip an image (in place) horizontally, vertically or both directions. */
 PHP_FUNCTION(imageflip)
@@ -5245,14 +4937,31 @@ PHP_FUNCTION(imageflip)
 }
 /* }}} */
 
+#ifdef HAVE_GD_BUNDLED
+/* {{{ proto bool imageantialias(resource im, bool on)
+   Should antialiased functions used or not*/
+PHP_FUNCTION(imageantialias)
+{
+	zval *IM;
+	zend_bool alias;
+	gdImagePtr im;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rb", &IM, &alias) == FAILURE) {
+		return;
+	}
+
+	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
+	gdImageAntialias(im, alias);
+	RETURN_TRUE;
+}
+/* }}} */
+#endif
+
 /* {{{ proto void imagecrop(resource im, array rect)
    Crop an image using the given coordinates and size, x, y, width and height. */
 PHP_FUNCTION(imagecrop)
 {
 	zval *IM;
-	long mode = -1;
-	long color = -1;
-	double threshold = 0.5f;
 	gdImagePtr im;
 	gdImagePtr im_crop;
 	gdRect rect;
@@ -5352,13 +5061,10 @@ PHP_FUNCTION(imagecropauto)
 /* }}} */
 
 /* {{{ proto resource imagescale(resource im, new_width[, new_height[, method]])
-   Crop an image using the given coordinates and size, x, y, width and height. */
+   Scale an image using the given new width and height. */
 PHP_FUNCTION(imagescale)
 {
 	zval *IM;
-	long mode = -1;
-	long color = -1;
-	double threshold = 0.5f;
 	gdImagePtr im;
 	gdImagePtr im_scaled;
 	int new_width, new_height = -1;
@@ -5407,9 +5113,6 @@ finish:
 PHP_FUNCTION(imageaffine)
 {
 	zval *IM;
-	long mode = -1;
-	long color = -1;
-	double threshold = 0.5f;
 	gdImagePtr src;
 	gdImagePtr dst;
 	gdRect rect;
@@ -5515,7 +5218,7 @@ PHP_FUNCTION(imageaffinematrixget)
 	gdAffineStandardMatrix type;
 	zval *options;
 	zval **tmp;
-	int res, i;
+	int res = GD_FALSE, i;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|z", &type, &options) == FAILURE)  {
 		return;
@@ -5575,9 +5278,13 @@ PHP_FUNCTION(imageaffinematrixget)
 			RETURN_FALSE;
 	}
 
-	array_init(return_value);
-	for (i = 0; i < 6; i++) {
-		add_index_double(return_value, i, affine[i]);
+	if (res == GD_FALSE) {
+		RETURN_FALSE;
+	} else {
+		array_init(return_value);
+		for (i = 0; i < 6; i++) {
+			add_index_double(return_value, i, affine[i]);
+		}
 	}
 }
 
@@ -5671,8 +5378,6 @@ PHP_FUNCTION(imagesetinterpolation)
 	RETURN_BOOL(gdImageSetInterpolationMethod(im, (gdInterpolationMethod) method));
 }
 /* }}} */
-#endif
-
 
 /*
  * Local variables:
--- /dev/null
+++ b/ext/gd/gd_compat.c
@@ -0,0 +1,47 @@
+#include "php_config.h"
+
+#ifdef HAVE_GD_PNG
+/* needs to be first */
+# include <png.h>
+#endif
+
+#ifdef HAVE_GD_JPG
+# include <jpeglib.h>
+#endif
+
+#include "gd_compat.h"
+
+#ifdef HAVE_GD_JPG
+int gdJpegGetVersionInt()
+{
+	return JPEG_LIB_VERSION;
+}
+
+const char * gdJpegGetVersionString()
+{
+	switch(JPEG_LIB_VERSION) {
+		case 62:
+			return "6b";
+			break;
+
+		case 70:
+			return "7";
+			break;
+
+		case 80:
+			return "8";
+			break;
+
+		default:
+			return "unknown";
+	}
+}
+#endif
+
+#ifdef HAVE_GD_PNG
+const char * gdPngGetVersionString()
+{
+	return PNG_LIBPNG_VER_STRING;
+}
+#endif
+
--- /dev/null
+++ b/ext/gd/gd_compat.h
@@ -0,0 +1,8 @@
+#ifndef GD_COMPAT_H
+#define GD_COMPAT_H 1
+
+const char * gdPngGetVersionString();
+const char * gdJpegGetVersionString();
+int gdJpegGetVersionInt();
+
+#endif /* GD_COMPAT_H */
--- a/ext/gd/gd_ctx.c
+++ b/ext/gd/gd_ctx.c
@@ -189,11 +189,7 @@ static void _php_image_output_ctx(INTERN
 			break;
 	}
 
-#if HAVE_LIBGD204
 	ctx->gd_free(ctx);
-#else
-	ctx->free(ctx);
-#endif
 
 	RETURN_TRUE;
 }
--- a/ext/gd/gdcache.c
+++ b/ext/gd/gdcache.c
@@ -44,7 +44,7 @@
 #else
 #include <php_config.h>
 #endif
-#if HAVE_LIBFREETYPE && !defined(HAVE_GD_CACHE_CREATE)
+#if HAVE_LIBFREETYPE && !defined(HAVE_GD_BUNDLED)
 
 #include "gdcache.h"
 
--- a/ext/gd/libgd/gd.c
+++ b/ext/gd/libgd/gd.c
@@ -1958,7 +1958,6 @@ static void _gdImageFillTiled(gdImagePtr
 {
 	int i, l, x1, x2, dy;
 	int oc;   /* old pixel value */
-	int tiled;
 	int wx2,wy2;
 	/* stack of filled segments */
 	struct seg *stack;
@@ -1970,7 +1969,6 @@ static void _gdImageFillTiled(gdImagePtr
 	}
 
 	wx2=im->sx;wy2=im->sy;
-	tiled = nc==gdTiled;
 
 	nc =  gdImageTileGet(im,x,y);
 
@@ -2035,7 +2033,6 @@ void gdImageRectangle (gdImagePtr im, in
 {
 	int x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;
 	int thick = im->thick;
-	int half1 = 1;
 	int t;
 
 	if (x1 == x2 && y1 == y2 && thick == 1) {
@@ -2057,7 +2054,7 @@ void gdImageRectangle (gdImagePtr im, in
 	if (thick > 1) {
 		int cx, cy, x1ul, y1ul, x2lr, y2lr;
 		int half = thick >> 1;
-		half1 = thick - half;
+
 		x1ul = x1 - half;
 		y1ul = y1 - half;
 		
@@ -2355,8 +2352,6 @@ void gdImageCopyResized (gdImagePtr dst,
 	int colorMap[gdMaxColors];
 	/* Stretch vectors */
 	int *stx, *sty;
-	/* We only need to use floating point to determine the correct stretch vector for one line's worth. */
-	double accum;
 	
 	if (overflow2(sizeof(int), srcW)) {
 		return;
@@ -2367,7 +2362,6 @@ void gdImageCopyResized (gdImagePtr dst,
 
 	stx = (int *) gdMalloc (sizeof (int) * srcW);
 	sty = (int *) gdMalloc (sizeof (int) * srcH);
-	accum = 0;
 
 	/* Fixed by Mao Morimoto 2.0.16 */
 	for (i = 0; (i < srcW); i++) {
@@ -3017,7 +3011,7 @@ void gdImageGetClip (gdImagePtr im, int
 int gdImagePaletteToTrueColor(gdImagePtr src)
 {
 	unsigned int y;
-	unsigned char alloc_y = 0, alloc_aa = 0;
+	unsigned char alloc_y = 0;
 	unsigned int yy;
 
 	if (src == NULL) {
--- a/ext/gd/libgd/gd.h
+++ b/ext/gd/libgd/gd.h
@@ -362,8 +362,12 @@ gdImagePtr gdImageCreateFromPng(FILE *fd
 gdImagePtr gdImageCreateFromPngCtx(gdIOCtxPtr in);
 gdImagePtr gdImageCreateFromWBMP(FILE *inFile);
 gdImagePtr gdImageCreateFromWBMPCtx(gdIOCtx *infile);
-gdImagePtr gdImageCreateFromJpeg(FILE *infile, int ignore_warning);
-gdImagePtr gdImageCreateFromJpegCtx(gdIOCtx *infile, int ignore_warning);
+gdImagePtr gdImageCreateFromJpeg(FILE *infile);
+gdImagePtr gdImageCreateFromJpegEx(FILE *infile, int ignore_warning);
+gdImagePtr gdImageCreateFromJpegCtx(gdIOCtx *infile);
+gdImagePtr gdImageCreateFromJpegCtxEx(gdIOCtx *infile, int ignore_warning);
+gdImagePtr gdImageCreateFromJpegPtr (int size, void *data);
+gdImagePtr gdImageCreateFromJpegPtrEx (int size, void *data, int ignore_warning);
 gdImagePtr gdImageCreateFromWebp(FILE *fd);
 gdImagePtr gdImageCreateFromWebpCtx(gdIOCtxPtr in);
 gdImagePtr gdImageCreateFromWebpPtr (int size, void *data);
--- a/ext/gd/libgd/gd_compat.c
+++ /dev/null
@@ -1,82 +0,0 @@
-#include "php_config.h" 
-#ifdef HAVE_GD_PNG
-/* needs to be first */
-# include <png.h>
-#endif
-
-#ifdef HAVE_GD_JPG
-# include <jpeglib.h>
-#endif
-
-#ifdef HAVE_GD_JPG
-int gdJpegGetVersionInt()
-{
-	return JPEG_LIB_VERSION;
-}
-
-const char * gdJpegGetVersionString()
-{
-	switch(JPEG_LIB_VERSION) {
-		case 62:
-			return "6b";
-			break;
-		default:
-			return "unknown";
-	}
-}
-#endif
-
-#ifdef HAVE_GD_PNG
-const char * gdPngGetVersionString()
-{
-	return PNG_LIBPNG_VER_STRING;
-}
-#endif
-
-/* Not exported by libgd, copied from gdhelpers.h */
-int overflow2(int a, int b)
-{
-	if(a <= 0 || b <= 0) {
-		return 1;
-	}
-	if(a > INT_MAX / b) {
-		return 1;
-	}
-	return 0;
-}
-
-/* Not exported by libgd, copied from wbmp.c */
-int
-getmbi (int (*getin) (void *in), void *in)
-{
-  int i, mbi = 0;
-
-  do
-    {
-      i = getin (in);
-      if (i < 0)
-	return (-1);
-      mbi = (mbi << 7) | (i & 0x7f);
-    }
-  while (i & 0x80);
-
-  return (mbi);
-}
-
-/* Not exported by libgd, copied from wbmp.c */
-int
-skipheader (int (*getin) (void *in), void *in)
-{
-  int i;
-
-  do
-    {
-      i = getin (in);
-      if (i < 0)
-	return (-1);
-    }
-  while (i & 0x80);
-
-  return (0);
-}
-
--- a/ext/gd/libgd/gd_compat.h
+++ /dev/null
@@ -1,69 +0,0 @@
-#ifndef GD_COMPAT_H
-#define GD_COMPAT_H 1
-
-#if HAVE_GD_BUNDLED
-# include "gd.h"
-#else
-# include <gd.h>
-#endif
-
-const char * gdPngGetVersionString();
-const char * gdJpegGetVersionString();
-int gdJpegGetVersionInt();
-int overflow2(int a, int b);
-int getmbi (int (*getin) (void *in), void *in);
-int skipheader (int (*getin) (void *in), void *in);
-
-
-/* filters section
- *
- * Negate the imag src, white becomes black,
- * The red, green, and blue intensities of an image are negated.
- * White becomes black, yellow becomes blue, etc.
- */
-int gdImageNegate(gdImagePtr src);
-
-/* Convert the image src to a grayscale image */
-int gdImageGrayScale(gdImagePtr src);
-
-/* Set the brightness level <brightness> for the image src */
-int gdImageBrightness(gdImagePtr src, int brightness);
-
-/* Set the contrast level <contrast> for the image <src> */
-int gdImageContrast(gdImagePtr src, double contrast);
-
-/* Simply adds or substracts respectively red, green or blue to a pixel */
-int gdImageColor(gdImagePtr src, const int red, const int green, const int blue, const int alpha);
-
-#if !defined(HAVE_GD_IMAGE_CONVOLUTION)
-/* Image convolution by a 3x3 custom matrix */
-int gdImageConvolution(gdImagePtr src, float ft[3][3], float filter_div, float offset);
-int gdImageEdgeDetectQuick(gdImagePtr src);
-int gdImageGaussianBlur(gdImagePtr im);
-int gdImageSelectiveBlur( gdImagePtr src);
-int gdImageEmboss(gdImagePtr im);
-int gdImageMeanRemoval(gdImagePtr im);
-int gdImageSmooth(gdImagePtr im, float weight);
-#endif
-
-#if !defined(HAVE_GD_IMAGE_PIXELATE)
-enum gdPixelateMode {
-	GD_PIXELATE_UPPERLEFT,
-	GD_PIXELATE_AVERAGE
-};
-
-int gdImagePixelate(gdImagePtr im, int block_size, const unsigned int mode);
-#endif
-
-int gdImagePixelate(gdImagePtr im, int block_size, const unsigned int mode);
-
-#if !HAVE_GD_IMAGEELLIPSE
-void gdImageEllipse(gdImagePtr im, int cx, int cy, int w, int h, int c);
-#endif
-
-gdImagePtr gdImageRotate (gdImagePtr src, double dAngle, int clrBack, int ignoretransparent);
-
-int gdImageColorMatch (gdImagePtr im1, gdImagePtr im2);
-
-#endif
-
--- a/ext/gd/libgd/gd_interpolation.c
+++ b/ext/gd/libgd/gd_interpolation.c
@@ -978,7 +978,7 @@ static inline void _gdScaleRow(gdImagePt
 
 		/* Accumulate each channel */
         for (i = left; i <= right; i++) {
-			const left_channel = i - left;
+			const int left_channel = i - left;
             r += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetRed(p_src_row[i])));
             g += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetGreen(p_src_row[i])));
             b += (unsigned char)(contrib->ContribRow[x].Weights[left_channel] * (double)(gdTrueColorGetBlue(p_src_row[i])));
--- a/ext/gd/libgd/gd_jpeg.c
+++ b/ext/gd/libgd/gd_jpeg.c
@@ -269,21 +269,31 @@ void gdImageJpegCtx (gdImagePtr im, gdIO
 	gdFree (row);
 }
 
-gdImagePtr gdImageCreateFromJpeg (FILE * inFile, int ignore_warning)
+gdImagePtr gdImageCreateFromJpeg (FILE * inFile)
+{
+	return gdImageCreateFromJpegEx(inFile, 1);
+}
+
+gdImagePtr gdImageCreateFromJpegEx (FILE * inFile, int ignore_warning)
 {
 	gdImagePtr im;
 	gdIOCtx *in = gdNewFileCtx(inFile);
-	im = gdImageCreateFromJpegCtx(in, ignore_warning);
+	im = gdImageCreateFromJpegCtxEx(in, ignore_warning);
 	in->gd_free (in);
 
 	return im;
 }
 
-gdImagePtr gdImageCreateFromJpegPtr (int size, void *data, int ignore_warning)
+gdImagePtr gdImageCreateFromJpegPtr (int size, void *data)
+{
+	return gdImageCreateFromJpegPtrEx(size, data, 1);
+}
+
+gdImagePtr gdImageCreateFromJpegPtrEx (int size, void *data, int ignore_warning)
 {
 	gdImagePtr im;
 	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
-	im = gdImageCreateFromJpegCtx(in, ignore_warning);
+	im = gdImageCreateFromJpegCtxEx(in, ignore_warning);
 	in->gd_free(in);
 
 	return im;
@@ -298,7 +308,12 @@ static int CMYKToRGB(int c, int m, int y
  * Create a gd-format image from the JPEG-format INFILE.  Returns the
  * image, or NULL upon error.
  */
-gdImagePtr gdImageCreateFromJpegCtx (gdIOCtx * infile, int ignore_warning)
+gdImagePtr gdImageCreateFromJpegCtx (gdIOCtx * infile)
+{
+	return gdImageCreateFromJpegCtxEx(infile, 1);
+}
+
+gdImagePtr gdImageCreateFromJpegCtxEx (gdIOCtx * infile, int ignore_warning)
 {
 	struct jpeg_decompress_struct cinfo;
 	struct jpeg_error_mgr jerr;
--- a/ext/gd/php_gd.h
+++ b/ext/gd/php_gd.h
@@ -22,15 +22,13 @@
 #ifndef PHP_GD_H
 #define PHP_GD_H
 
-#define HAVE_GDIMAGECREATEFROMPNG 1
-
 #if HAVE_LIBFREETYPE
 # ifndef ENABLE_GD_TTF
 #  define ENABLE_GD_TTF
 # endif
 #endif
 
-#if HAVE_LIBGD
+#if defined(HAVE_LIBGD) || defined(HAVE_GD_BUNDLED)
 
 /* open_basedir and safe_mode checks */
 #define PHP_GD_CHECK_OPEN_BASEDIR(filename, errormsg)                       \
@@ -69,10 +67,10 @@ extern zend_module_entry gd_module_entry
 /* gd.c functions */
 PHP_MINFO_FUNCTION(gd);
 PHP_MINIT_FUNCTION(gd);
-#if HAVE_LIBT1 || HAVE_GD_FONTMUTEX
+#if HAVE_LIBT1
 PHP_MSHUTDOWN_FUNCTION(gd);
 #endif
-#if HAVE_GD_STRINGFT
+#if HAVE_GD_FREETYPE && HAVE_LIBFREETYPE
 PHP_RSHUTDOWN_FUNCTION(gd);
 #endif
 
@@ -123,9 +121,12 @@ PHP_FUNCTION(imagegrabscreen);
 
 PHP_FUNCTION(imagerotate);
 
+PHP_FUNCTION(imageflip);
+
 #ifdef HAVE_GD_BUNDLED
 PHP_FUNCTION(imageantialias);
-PHP_FUNCTION(imageflip);
+#endif
+
 PHP_FUNCTION(imagecrop);
 PHP_FUNCTION(imagecropauto);
 PHP_FUNCTION(imagescale);
@@ -133,7 +134,6 @@ PHP_FUNCTION(imageaffine);
 PHP_FUNCTION(imageaffinematrixget);
 PHP_FUNCTION(imageaffinematrixconcat);
 PHP_FUNCTION(imagesetinterpolation);
-#endif
 
 PHP_FUNCTION(imagesetthickness);
 PHP_FUNCTION(imagecopymergegray);
@@ -151,7 +151,7 @@ PHP_FUNCTION(imagecreatefromwbmp);
 PHP_FUNCTION(imagecreatefromgd);
 PHP_FUNCTION(imagecreatefromgd2);
 PHP_FUNCTION(imagecreatefromgd2part);
-#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)
+#if defined(HAVE_GD_XPM)
 PHP_FUNCTION(imagecreatefromxpm);
 #endif
 
@@ -202,10 +202,8 @@ PHP_FUNCTION(image2wbmp);
 
 PHP_FUNCTION(imagecolormatch);
 
-#if HAVE_GD_BUNDLED
 PHP_FUNCTION(imagelayereffect);
 PHP_FUNCTION(imagexbm);
-#endif
 
 PHP_FUNCTION(imagefilter);
 PHP_FUNCTION(imageconvolution);
--- a/ext/mysqli/mysqli.c
+++ b/ext/mysqli/mysqli.c
@@ -1271,7 +1271,7 @@ void php_mysqli_fetch_into_hash(INTERNAL
 
 	php_mysqli_fetch_into_hash_aux(return_value, result, fetchtype TSRMLS_CC);
 
-	if (into_object && Z_TYPE_P(return_value) != IS_NULL) {
+	if (into_object && Z_TYPE_P(return_value) == IS_ARRAY) {
 		zval dataset = *return_value;
 		zend_fcall_info fci;
 		zend_fcall_info_cache fcc;
--- /dev/null
+++ b/ext/mysqli/tests/bug64726.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Bug #63398 (Segfault when calling fetch_object on a use_result and DB pointer has closed)
+--SKIPIF--
+<?php
+require_once('skipif.inc');
+require_once("connect.inc");
+if (!$IS_MYSQLND) {
+    die("skip mysqlnd only test");
+}
+require_once('skipifconnectfailure.inc');
+?>
+--FILE--
+<?php
+require 'connect.inc';
+$db = new my_mysqli($host, $user, $passwd, $db, $port, $socket);
+
+$result = $db->query('SELECT 1', MYSQLI_USE_RESULT);
+$db->close();
+var_dump($result->fetch_object());
+?>
+--EXPECTF--
+Warning: mysqli_result::fetch_object(): Error while reading a row in %sbug64726.php on line %d
+bool(false)
--- a/ext/mysqlnd/mysqlnd.c
+++ b/ext/mysqlnd/mysqlnd.c
@@ -27,6 +27,7 @@
 #include "mysqlnd_statistics.h"
 #include "mysqlnd_charset.h"
 #include "mysqlnd_debug.h"
+#include "ext/standard/php_smart_str.h"
 
 /*
   TODO :
--- a/ext/mysqlnd/mysqlnd_result.c
+++ b/ext/mysqlnd/mysqlnd_result.c
@@ -1479,6 +1479,7 @@ MYSQLND_METHOD(mysqlnd_res, fetch_into)(
 	mysqlnd_array_init(return_value, mysqlnd_num_fields(result) * 2);
 	if (FAIL == result->m.fetch_row(result, (void *)return_value, flags, &fetched_anything TSRMLS_CC)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error while reading a row");
+		zval_dtor(return_value);
 		RETVAL_FALSE;
 	} else if (fetched_anything == FALSE) {
 		zval_dtor(return_value);
--- a/ext/mysqlnd/mysqlnd_structs.h
+++ b/ext/mysqlnd/mysqlnd_structs.h
@@ -23,7 +23,7 @@
 #ifndef MYSQLND_STRUCTS_H
 #define MYSQLND_STRUCTS_H
 
-#include "ext/standard/php_smart_str.h"
+#include "ext/standard/php_smart_str_public.h"
 
 #define MYSQLND_TYPEDEFED_METHODS
 
--- a/ext/opcache/Optimizer/block_pass.c
+++ b/ext/opcache/Optimizer/block_pass.c
@@ -1257,14 +1257,15 @@ static void assemble_code_blocks(zend_cf
 		}
 		cur_block = cur_block->next;
 	}
-#if ZEND_EXTENSION_API_NO < PHP_5_3_X_API_NO
-	if (opline[-1].opcode == ZEND_THROW) {
+
+	if ((opline-1)->opcode == ZEND_THROW) {
 		/* if we finished with THROW, we need to add space between THROW and HANDLE to not confuse
 		   zend_throw_internal */
 		MAKE_NOP(opline);
 		opline->lineno = opline[-1].lineno;
 		opline++;
 	}
+#if ZEND_EXTENSION_API_NO < PHP_5_3_X_API_NO
 	MAKE_NOP(opline);
 	opline->opcode = ZEND_HANDLE_EXCEPTION;
 	opline->lineno = opline[-1].lineno;
--- a/ext/opcache/Optimizer/zend_optimizer_internal.h
+++ b/ext/opcache/Optimizer/zend_optimizer_internal.h
@@ -26,7 +26,7 @@
 
 #if ZEND_EXTENSION_API_NO > PHP_5_4_X_API_NO
 # define VAR_NUM(v) ((zend_uint)(EX_TMP_VAR_NUM(0, 0) - EX_TMP_VAR(0, v)))
-# define NUM_VAR(v) ((zend_uint)EX_TMP_VAR_NUM(0, v))
+# define NUM_VAR(v) ((zend_uint)(zend_uintptr_t)EX_TMP_VAR_NUM(0, v))
 #else
 # define VAR_NUM(v) ((v)/(sizeof(temp_variable)))
 # define NUM_VAR(v) ((v)*(sizeof(temp_variable)))
--- a/ext/snmp/config.m4
+++ b/ext/snmp/config.m4
@@ -59,67 +59,6 @@ if test "$PHP_SNMP" != "no"; then
     $SNMP_SHARED_LIBADD
   ])
 
-  dnl Check for buggy snmp_snprint_value() (net-snmp BUGid 2027834)
-  AC_CACHE_CHECK([for buggy snmp_snprint_value], ac_cv_buggy_snprint_value,[
-    save_CFLAGS="$CFLAGS"
-    CFLAGS="$CFLAGS -I${SNMP_PREFIX}/include $SNMP_SHARED_LIBADD"
-    AC_TRY_RUN( [
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <net-snmp/net-snmp-config.h>
-#include <net-snmp/net-snmp-includes.h>
-
-u_char uname[] = "Linux nex1.php.net 2.6.18-194.32.1.el5 #1 SMP Wed Jan 5 17:53:09 EST 2011 i686";
-
-int main(int argc, char **argv)
-{
-	struct variable_list vars;
-	char buf1[2048];
-	char buf2[sizeof(buf1)];
-	
-	memset(&(buf1[0]), 0, sizeof(buf1));
-	memset(&(buf2[0]), 0, sizeof(buf2));
-	memset(&vars, 0, sizeof(vars));
-	vars.type = 4;
-	vars.val.integer = (long *)&(uname[0]);
-	vars.val.string = &(uname[0]);
-	vars.val.bitstring = &(uname[0]);
-	vars.val.counter64 = (struct counter64 *)&(uname[0]);
-	vars.val.floatVal = (float *)&(uname[0]);
-	vars.val_len = sizeof(uname),
-	vars.name_loc[0] = 1;
-	vars.name_loc[1] = 3;
-	vars.name_loc[2] = 6;
-	vars.name_loc[3] = 1;
-	vars.name_loc[4] = 2;
-	vars.name_loc[5] = 1;
-	vars.name_loc[6] = 1;
-	vars.name_loc[7] = 1;
-	vars.name = (oid *)&(vars.name_loc);
-	vars.name_length = 9;
-
-	init_snmp("snmpapp");
-
-	netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT, 0);
-
-	snprint_value(buf1, (sizeof(uname) + 32), vars.name, vars.name_length, &vars);
-	snprint_value(buf2, sizeof(buf2), vars.name, vars.name_length, &vars);
-	exit((strncmp(buf1, buf2, sizeof(buf1)) != 0));
-}
-    ],[
-      ac_cv_buggy_snprint_value=no
-    ],[
-      ac_cv_buggy_snprint_value=yes
-    ],[
-      ac_cv_buggy_snprint_value=no
-    ])
-    CFLAGS="$save_CFLAGS"
-  ])
-  if test "$ac_cv_buggy_snprint_value" = "yes"; then
-     AC_DEFINE(BUGGY_SNMPRINT_VALUE, 1, [ ])
-  fi
-
   PHP_NEW_EXTENSION(snmp, snmp.c, $ext_shared)
   PHP_SUBST(SNMP_SHARED_LIBADD)
 fi
--- a/ext/snmp/snmp.c
+++ b/ext/snmp/snmp.c
@@ -80,14 +80,6 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
-#if PHP_VERSION_ID < 50300
-#define Z_ADDREF_P(pz) pz->refcount++
-#define Z_ISREF_PP(oid) (PZVAL_IS_REF(*(oid)))
-#define Z_REFCOUNT_P(pz) pz->refcount
-#define Z_SET_REFCOUNT_P(pz, rc) pz->refcount = rc
-#define zend_parse_parameters_none() zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "")
-#endif
-
 /* For net-snmp prior to 5.4 */
 #ifndef HAVE_SHUTDOWN_SNMP_LOGGING
 extern netsnmp_log_handler *logh_head;
@@ -497,9 +489,6 @@ static void php_snmp_object_free_storage
 
 static zend_object_value php_snmp_object_new(zend_class_entry *class_type TSRMLS_DC) /* {{{ */
 {
-#if PHP_VERSION_ID < 50399
-	zval *tmp;
-#endif
 	zend_object_value retval;
 	php_snmp_object *intern;
 
@@ -508,11 +497,7 @@ static zend_object_value php_snmp_object
 	memset(&intern->zo, 0, sizeof(php_snmp_object));
 
 	zend_object_std_init(&intern->zo, class_type TSRMLS_CC);
-#if PHP_VERSION_ID < 50399
-	zend_hash_copy(intern->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &tmp, sizeof(zval *));
-#else
 	object_properties_init(&intern->zo, class_type);
-#endif
 
 	retval.handle = zend_objects_store_put(intern, (zend_objects_store_dtor_t)zend_objects_destroy_object, (zend_objects_free_object_storage_t) php_snmp_object_free_storage, NULL TSRMLS_CC);
 	retval.handlers = (zend_object_handlers *) &php_snmp_object_handlers;
@@ -566,35 +551,60 @@ static void php_snmp_error(zval *object,
 static void php_snmp_getvalue(struct variable_list *vars, zval *snmpval TSRMLS_DC, int valueretrieval)
 {
 	zval *val;
-#ifdef BUGGY_SNMPRINT_VALUE
-	char sbuf[2048];
-#else
-	char sbuf[64];
-#endif
+	char sbuf[512];
 	char *buf = &(sbuf[0]);
 	char *dbuf = (char *)NULL;
 	int buflen = sizeof(sbuf) - 1;
 	int val_len = vars->val_len;
 	
-	if ((valueretrieval & SNMP_VALUE_PLAIN) == 0) {
-		val_len += 32; /* snprint_value will add type info into value, make some space for it */
+	/* use emalloc() for large values, use static array otherwize */
+
+	/* There is no way to know the size of buffer snprint_value() needs in order to print a value there.
+	 * So we are forced to probe it
+	 */
+	while ((valueretrieval & SNMP_VALUE_PLAIN) == 0) {
+		*buf = '\0';
+		if (snprint_value(buf, buflen, vars->name, vars->name_length, vars) == -1) {
+			if (val_len > 512*1024) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "snprint_value() asks for a buffer more than 512k, Net-SNMP bug?");
+				break;
+			}
+			 /* buffer is not long enough to hold full output, double it */
+			val_len *= 2;
+		} else {
+			break;
+		}
+
+		if (buf == dbuf) {
+			dbuf = (char *)erealloc(dbuf, val_len + 1);
+		} else {
+			dbuf = (char *)emalloc(val_len + 1);
+		}
+
+		if (!dbuf) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "emalloc() failed: %s, fallback to static buffer", strerror(errno));
+			buf = &(sbuf[0]);
+			buflen = sizeof(sbuf) - 1;
+			break;
+		}
+
+		buf = dbuf;
+		buflen = val_len;
 	}
 
-	/* use emalloc() for large values, use static array otherwize */
-	if(val_len > buflen){
+	if((valueretrieval & SNMP_VALUE_PLAIN) && val_len > buflen){
 		if ((dbuf = (char *)emalloc(val_len + 1))) {
 			buf = dbuf;
 			buflen = val_len;
 		} else {
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "emalloc() failed: %s, fallback to static array", strerror(errno));
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "emalloc() failed: %s, fallback to static buffer", strerror(errno));
 		}
 	}
 
-	*buf = 0;
-
 	MAKE_STD_ZVAL(val);
 
 	if (valueretrieval & SNMP_VALUE_PLAIN) {
+		*buf = 0;
 		switch (vars->type) {
 		case ASN_BIT_STR:		/* 0x03, asn1.h */
 			ZVAL_STRINGL(val, (char *)vars->val.bitstring, vars->val_len, 1);
@@ -667,7 +677,7 @@ static void php_snmp_getvalue(struct var
 			break;
 		}
 	} else /* use Net-SNMP value translation */ {
-		snprint_value(buf, buflen, vars->name, vars->name_length, vars);
+		/* we have desired string in buffer, just use it */
 		ZVAL_STRING(val, buf, 1);
 	}
 
@@ -1177,9 +1187,10 @@ static int netsnmp_session_init(php_snmp
 			continue;
 		}
 		if ((*res)->sa_family == AF_INET6) {
-			strcpy(session->peername, "udp6:");
+			strcpy(session->peername, "udp6:[");
 			pptr = session->peername + strlen(session->peername);
 			inet_ntop((*res)->sa_family, &(((struct sockaddr_in6*)(*res))->sin6_addr), pptr, MAX_NAME_LEN);
+			strcat(pptr, "]");
 		} else if ((*res)->sa_family == AF_INET) {
 			inet_ntop((*res)->sa_family, &(((struct sockaddr_in*)(*res))->sin_addr), pptr, MAX_NAME_LEN);
 		} else {
@@ -1775,11 +1786,7 @@ PHP_FUNCTION(snmp_read_mib)
 	char *filename;
 	int filename_len;
 
-#if PHP_VERSION_ID < 50399
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &filename, &filename_len) == FAILURE) {
-#else
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "p", &filename, &filename_len) == FAILURE) {
-#endif
 		RETURN_FALSE;
 	}
 
@@ -1804,31 +1811,17 @@ PHP_METHOD(snmp, __construct)
 	long retries = SNMP_DEFAULT_RETRIES;
 	long version = SNMP_DEFAULT_VERSION;
 	int argc = ZEND_NUM_ARGS();
-#if PHP_VERSION_ID > 50300
 	zend_error_handling error_handling;
-#endif
 
 	snmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC);
-#if PHP_VERSION_ID > 50300
 	zend_replace_error_handling(EH_THROW, NULL, &error_handling TSRMLS_CC);
-#else
-	php_set_error_handling(EH_THROW, zend_exception_get_default(TSRMLS_C) TSRMLS_CC);
-#endif
 	
 	if (zend_parse_parameters(argc TSRMLS_CC, "lss|ll", &version, &a1, &a1_len, &a2, &a2_len, &timeout, &retries) == FAILURE) {
-#if PHP_VERSION_ID > 50300
 		zend_restore_error_handling(&error_handling TSRMLS_CC);
-#else
-		php_std_error_handling();
-#endif
 		return;
 	}
 
-#if PHP_VERSION_ID > 50300
 	zend_restore_error_handling(&error_handling TSRMLS_CC);
-#else
-	php_std_error_handling();
-#endif
 
 	switch(version) {
 		case SNMP_VERSION_1:
@@ -1976,11 +1969,7 @@ void php_snmp_add_property(HashTable *h,
 
 /* {{{ php_snmp_read_property(zval *object, zval *member, int type[, const zend_literal *key])
    Generic object property reader */
-#if PHP_VERSION_ID < 50399
-zval *php_snmp_read_property(zval *object, zval *member, int type TSRMLS_DC)
-#else
 zval *php_snmp_read_property(zval *object, zval *member, int type, const zend_literal *key TSRMLS_DC)
-#endif
 {
 	zval tmp_member;
 	zval *retval;
@@ -2010,11 +1999,7 @@ zval *php_snmp_read_property(zval *objec
 		}
 	} else {
 		zend_object_handlers * std_hnd = zend_get_std_object_handlers();
-#if PHP_VERSION_ID < 50399
-		retval = std_hnd->read_property(object, member, type TSRMLS_CC);
-#else
 		retval = std_hnd->read_property(object, member, type, key TSRMLS_CC);
-#endif
 	}
 
 	if (member == &tmp_member) {
@@ -2026,11 +2011,7 @@ zval *php_snmp_read_property(zval *objec
 
 /* {{{ php_snmp_write_property(zval *object, zval *member, zval *value[, const zend_literal *key])
    Generic object property writer */
-#if PHP_VERSION_ID < 50399
-void php_snmp_write_property(zval *object, zval *member, zval *value TSRMLS_DC)
-#else
 void php_snmp_write_property(zval *object, zval *member, zval *value, const zend_literal *key TSRMLS_DC)
-#endif
 {
 	zval tmp_member;
 	php_snmp_object *obj;
@@ -2057,11 +2038,7 @@ void php_snmp_write_property(zval *objec
 		}
 	} else {
 		zend_object_handlers * std_hnd = zend_get_std_object_handlers();
-#if PHP_VERSION_ID < 50399
-		std_hnd->write_property(object, member, value TSRMLS_CC);
-#else
 		std_hnd->write_property(object, member, value, key TSRMLS_CC);
-#endif
 	}
 
 	if (member == &tmp_member) {
@@ -2072,11 +2049,7 @@ void php_snmp_write_property(zval *objec
 
 /* {{{ php_snmp_has_property(zval *object, zval *member, int has_set_exists[, const zend_literal *key])
    Generic object property checker */
-#if PHP_VERSION_ID < 50399
-static int php_snmp_has_property(zval *object, zval *member, int has_set_exists TSRMLS_DC)
-#else
 static int php_snmp_has_property(zval *object, zval *member, int has_set_exists, const zend_literal *key TSRMLS_DC)
-#endif
 {
 	php_snmp_prop_handler *hnd;
 	int ret = 0;
@@ -2087,11 +2060,7 @@ static int php_snmp_has_property(zval *o
 				ret = 1;
 				break;
 			case 0: {
-#if PHP_VERSION_ID < 50399
-				zval *value = php_snmp_read_property(object, member, BP_VAR_IS TSRMLS_CC);
-#else
 				zval *value = php_snmp_read_property(object, member, BP_VAR_IS, key TSRMLS_CC);
-#endif
 				if (value != EG(uninitialized_zval_ptr)) {
 					ret = Z_TYPE_P(value) != IS_NULL? 1:0;
 					/* refcount is 0 */
@@ -2101,11 +2070,7 @@ static int php_snmp_has_property(zval *o
 				break;
 			}
 			default: {
-#if PHP_VERSION_ID < 50399
-				zval *value = php_snmp_read_property(object, member, BP_VAR_IS TSRMLS_CC);
-#else
 				zval *value = php_snmp_read_property(object, member, BP_VAR_IS, key TSRMLS_CC);
-#endif
 				if (value != EG(uninitialized_zval_ptr)) {
 					convert_to_boolean(value);
 					ret = Z_BVAL_P(value)? 1:0;
@@ -2118,11 +2083,7 @@ static int php_snmp_has_property(zval *o
 		}
 	} else {
 		zend_object_handlers * std_hnd = zend_get_std_object_handlers();
-#if PHP_VERSION_ID < 50399
-		ret = std_hnd->has_property(object, member, has_set_exists TSRMLS_CC);
-#else
 		ret = std_hnd->has_property(object, member, has_set_exists, key TSRMLS_CC);
-#endif
 	}
 	return ret;
 }
@@ -2142,11 +2103,7 @@ static HashTable *php_snmp_get_propertie
 	ulong num_key;
 
 	obj = (php_snmp_object *)zend_objects_get_address(object TSRMLS_CC);
-#if PHP_VERSION_ID < 50399
-	props = obj->zo.properties;
-#else
 	props = zend_std_get_properties(object TSRMLS_CC);
-#endif
 
 	zend_hash_internal_pointer_reset_ex(&php_snmp_properties, &pos);
 
--- a/ext/snmp/tests/README
+++ b/ext/snmp/tests/README
@@ -35,6 +35,8 @@ On Linux/FreeBSD
 Before launching daemon make sure that there is no file /var/net-snmp/snmpd.conf
 Delete it if exists. Ingoring to to so will fail SNMPv3 tests.
 
+- Place bigtest.sh near snmpd.conf, tune path to it in snmpd.conf
+
 - Launch snmpd (service snmpd start or /etc/init.d/snmpd start).
   Alternatively you can start snmpd daemon using following command line:
     sudo snmpd -C -c ./snmpd.conf -f -Le
--- /dev/null
+++ b/ext/snmp/tests/bigtest.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+Q="";
+i=0;
+while [ $i -lt 32 ]; do
+	Q="${Q}\3\2\4\11\22\13\14\15\16\17\20\21\22\23\24\25\26\27";
+	i=$((i+1));
+done
+
+printf "${Q}"
--- /dev/null
+++ b/ext/snmp/tests/bug64159.phpt
@@ -0,0 +1,24 @@
+--TEST--                                 
+Bug #64159: Truncated snmpget
+--CREDITS--
+Boris Lytochkin
+--SKIPIF--
+<?php
+require_once(dirname(__FILE__).'/skipif.inc');
+?>
+--ENV--
+MIBS=noneXistent
+--FILE--
+<?php
+require_once(dirname(__FILE__).'/snmp_include.inc');
+
+snmp_set_quick_print(false);
+snmp_set_valueretrieval(SNMP_VALUE_LIBRARY);
+
+var_dump(("ab8283f948419b2d24d22f44a80b17d3" === md5(snmpget($hostname, $community, '.1.3.6.1.4.1.2021.8.1.101.2'))));
+
+?>
+--EXPECTF--
+MIB search path: %s
+Cannot find module (noneXistent): At line %d in (%s)
+bool(true)
--- a/ext/snmp/tests/snmp-object.phpt
+++ b/ext/snmp/tests/snmp-object.phpt
@@ -90,12 +90,6 @@ array_shift($z);
 var_dump(key($z));
 array_shift($z);
 var_dump(key($z));
-array_shift($z);
-var_dump(key($z));
-array_shift($z);
-var_dump(key($z));
-array_shift($z);
-var_dump(key($z));
 var_dump($session->close());
 
 echo "SNMPv3 (default security settings)\n";
@@ -211,9 +205,6 @@ string(3) "2.0"
 string(3) "3.0"
 string(3) "4.0"
 string(3) "5.0"
-string(3) "6.0"
-string(3) "7.0"
-string(3) "8.0"
 bool(true)
 SNMPv3 (default security settings)
 string(%d) "%S"
--- a/ext/snmp/tests/snmpd.conf
+++ b/ext/snmp/tests/snmpd.conf
@@ -23,3 +23,5 @@ createUser adminMD5DES MD5 test1234 DES
 
 createUser noAuthUser
 authuser read noAuthUser noauth
+
+exec HexTest /bin/sh /etc/snmp/bigtest.sh
--- a/ext/soap/php_http.c
+++ b/ext/soap/php_http.c
@@ -162,6 +162,7 @@ static php_stream* http_connect(zval* th
 	zval **proxy_host, **proxy_port, **tmp;
 	char *host;
 	char *name;
+	char *protocol;
 	long namelen;
 	int port;
 	int old_error_reporting;
@@ -189,7 +190,41 @@ static php_stream* http_connect(zval* th
 	old_error_reporting = EG(error_reporting);
 	EG(error_reporting) &= ~(E_WARNING|E_NOTICE|E_USER_WARNING|E_USER_NOTICE);
 
-	namelen = spprintf(&name, 0, "%s://%s:%d", (use_ssl && !*use_proxy)? "ssl" : "tcp", host, port);
+	/* Changed ternary operator to an if/else so that additional comparisons can be done on the ssl_method property */
+	if (use_ssl && !*use_proxy) {
+		if (zend_hash_find(Z_OBJPROP_P(this_ptr), "_ssl_method", sizeof("_ssl_method"), (void **) &tmp) == SUCCESS &&
+			Z_TYPE_PP(tmp) == IS_LONG) {
+			/* uses contants declared in soap.c to determine ssl uri protocol */
+			switch (Z_LVAL_PP(tmp)) {
+				case SOAP_SSL_METHOD_TLS:
+					protocol = "tls";
+					break;
+
+				case SOAP_SSL_METHOD_SSLv2:
+					protocol = "sslv2";
+					break;
+
+				case SOAP_SSL_METHOD_SSLv3:
+					protocol = "sslv3";
+					break;
+
+				case SOAP_SSL_METHOD_SSLv23:
+					protocol = "ssl";
+					break;
+
+				default:
+					protocol = "ssl";
+					break;
+
+			}
+		} else {
+			protocol = "ssl";
+		}
+	} else {
+		protocol = "tcp";
+	}
+
+	namelen = spprintf(&name, 0, "%s://%s:%d", protocol, host, port);
 
 	stream = php_stream_xport_create(name, namelen,
 		REPORT_ERRORS,
@@ -237,7 +272,34 @@ static php_stream* http_connect(zval* th
 		}
 		/* enable SSL transport layer */
 		if (stream) {
-			if (php_stream_xport_crypto_setup(stream, STREAM_CRYPTO_METHOD_SSLv23_CLIENT, NULL TSRMLS_CC) < 0 ||
+			/* if a stream is created without encryption, check to see if SSL method parameter is specified and use
+ 			   proper encrypyion method based on constants defined in soap.c */
+			int crypto_method = STREAM_CRYPTO_METHOD_SSLv23_CLIENT;
+			if (zend_hash_find(Z_OBJPROP_P(this_ptr), "_ssl_method", sizeof("_ssl_method"), (void **) &tmp) == SUCCESS &&
+				Z_TYPE_PP(tmp) == IS_LONG) {
+				switch (Z_LVAL_PP(tmp)) {
+					case SOAP_SSL_METHOD_TLS:
+						crypto_method = STREAM_CRYPTO_METHOD_TLS_CLIENT;
+						break;
+
+					case SOAP_SSL_METHOD_SSLv2:
+						crypto_method = STREAM_CRYPTO_METHOD_SSLv2_CLIENT;
+						break;
+
+					case SOAP_SSL_METHOD_SSLv3:
+						crypto_method = STREAM_CRYPTO_METHOD_SSLv3_CLIENT;
+						break;
+
+					case SOAP_SSL_METHOD_SSLv23:
+						crypto_method = STREAM_CRYPTO_METHOD_SSLv23_CLIENT;
+						break;
+
+					default:
+						crypto_method = STREAM_CRYPTO_METHOD_TLS_CLIENT;
+						break;
+				}
+			}
+			if (php_stream_xport_crypto_setup(stream, crypto_method, NULL TSRMLS_CC) < 0 ||
 			    php_stream_xport_crypto_enable(stream, 1 TSRMLS_CC) < 0) {
 				php_stream_close(stream);
 				stream = NULL;
--- a/ext/soap/php_soap.h
+++ b/ext/soap/php_soap.h
@@ -149,6 +149,13 @@ struct _soapService {
 #define WSDL_CACHE_MEMORY   0x2
 #define WSDL_CACHE_BOTH     0x3
 
+/* New SOAP SSL Method Constants */
+#define SOAP_SSL_METHOD_TLS     0
+#define SOAP_SSL_METHOD_SSLv2   1
+#define SOAP_SSL_METHOD_SSLv3   2
+#define SOAP_SSL_METHOD_SSLv23  3
+
+
 ZEND_BEGIN_MODULE_GLOBALS(soap)
 	HashTable  defEncNs;     /* mapping of default namespaces to prefixes */
 	HashTable  defEnc;
--- a/ext/soap/soap.c
+++ b/ext/soap/soap.c
@@ -753,6 +753,12 @@ PHP_MINIT_FUNCTION(soap)
 	REGISTER_LONG_CONSTANT("WSDL_CACHE_MEMORY", WSDL_CACHE_MEMORY, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("WSDL_CACHE_BOTH",   WSDL_CACHE_BOTH,   CONST_CS | CONST_PERSISTENT);
 
+	/* New SOAP SSL Method Constants */
+	REGISTER_LONG_CONSTANT("SOAP_SSL_METHOD_TLS",    SOAP_SSL_METHOD_TLS,    CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("SOAP_SSL_METHOD_SSLv2",  SOAP_SSL_METHOD_SSLv2,  CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("SOAP_SSL_METHOD_SSLv3",  SOAP_SSL_METHOD_SSLv3,  CONST_CS | CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("SOAP_SSL_METHOD_SSLv23", SOAP_SSL_METHOD_SSLv23, CONST_CS | CONST_PERSISTENT);
+
 	old_error_handler = zend_error_cb;
 	zend_error_cb = soap_error_handler;
 
@@ -2497,6 +2503,11 @@ PHP_METHOD(SoapClient, SoapClient)
 				(Z_TYPE_PP(tmp) == IS_BOOL || Z_TYPE_PP(tmp) == IS_LONG) && Z_LVAL_PP(tmp) == 0) {
 			add_property_long(this_ptr, "_keep_alive", 0);
 		}
+
+		if (zend_hash_find(ht, "ssl_method", sizeof("ssl_method"), (void**)&tmp) == SUCCESS &&
+			Z_TYPE_PP(tmp) == IS_LONG) {
+			add_property_long(this_ptr, "_ssl_method", Z_LVAL_PP(tmp));
+		}
 	} else if (Z_TYPE_P(wsdl) == IS_NULL) {
 		php_error_docref(NULL TSRMLS_CC, E_ERROR, "'location' and 'uri' options are required in nonWSDL mode");
 	}
--- a/ext/standard/streamsfuncs.c
+++ b/ext/standard/streamsfuncs.c
@@ -601,7 +601,6 @@ static int stream_array_to_fd_set(zval *
 {
 	zval **elem;
 	php_stream *stream;
-	php_socket_t this_fd;
 	int cnt = 0;
 
 	if (Z_TYPE_P(stream_array) != IS_ARRAY) {
@@ -611,6 +610,11 @@ static int stream_array_to_fd_set(zval *
 		 zend_hash_get_current_data(Z_ARRVAL_P(stream_array), (void **) &elem) == SUCCESS;
 		 zend_hash_move_forward(Z_ARRVAL_P(stream_array))) {
 
+		/* Temporary int fd is needed for the STREAM data type on windows, passing this_fd directly to php_stream_cast()
+			would eventually bring a wrong result on x64. php_stream_cast() casts to int internally, and this will leave
+			the higher bits of a SOCKET variable uninitialized on systems with little endian. */
+		int tmp_fd;
+
 		php_stream_from_zval_no_verify(stream, elem);
 		if (stream == NULL) {
 			continue;
@@ -620,7 +624,9 @@ static int stream_array_to_fd_set(zval *
 		 * when casting.  It is only used here so that the buffered data warning
 		 * is not displayed.
 		 * */
-		if (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void*)&this_fd, 1) && this_fd != -1) {
+		if (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void*)&tmp_fd, 1) && tmp_fd != -1) {
+
+			php_socket_t this_fd = (php_socket_t)tmp_fd;
 
 			PHP_SAFE_FD_SET(this_fd, fds);
 
@@ -638,7 +644,6 @@ static int stream_array_from_fd_set(zval
 	zval **elem, **dest_elem;
 	php_stream *stream;
 	HashTable *new_hash;
-	php_socket_t this_fd;
 	int ret = 0;
 
 	if (Z_TYPE_P(stream_array) != IS_ARRAY) {
@@ -655,6 +660,11 @@ static int stream_array_from_fd_set(zval
 		char *key;
 		uint key_len;
 		ulong num_ind;
+		/* Temporary int fd is needed for the STREAM data type on windows, passing this_fd directly to php_stream_cast()
+			would eventually bring a wrong result on x64. php_stream_cast() casts to int internally, and this will leave
+			the higher bits of a SOCKET variable uninitialized on systems with little endian. */
+		int tmp_fd;
+
 
 		type = zend_hash_get_current_key_ex(Z_ARRVAL_P(stream_array),
 				&key, &key_len, &num_ind, 0, NULL);
@@ -672,7 +682,10 @@ static int stream_array_from_fd_set(zval
 		 * when casting.  It is only used here so that the buffered data warning
 		 * is not displayed.
 		 */
-		if (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void*)&this_fd, 1) && this_fd != -1) {
+		if (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void*)&tmp_fd, 1) && tmp_fd != -1) {
+
+			php_socket_t this_fd = (php_socket_t)tmp_fd;
+
 			if (PHP_SAFE_FD_ISSET(this_fd, fds)) {
 				if (type == HASH_KEY_IS_LONG) {
 					zend_hash_index_update(new_hash, num_ind, (void *)elem, sizeof(zval *), (void **)&dest_elem);
--- a/ext/standard/tests/file/bug24482.phpt
+++ b/ext/standard/tests/file/bug24482.phpt
@@ -8,6 +8,11 @@ if (!function_exists("glob")) {
 ?>
 --FILE--
 <?php
+
+// run this test in ext/standard/tests (see bug #64714)
+chdir(__DIR__); // ensure in ext/standard/tests/file
+chdir('..'); // move up to ext/standard/tests
+
 $globdirs = glob("*", GLOB_ONLYDIR);
 
 $dirs = array();
--- /dev/null
+++ b/ext/standard/tests/streams/bug64770.phpt
@@ -0,0 +1,52 @@
+--TEST--
+Bug #64770 stream_select() fails with pipes from proc_open() 
+--FILE--
+<?php
+
+$descs = array(
+	0 => array('pipe', 'r'), // stdin
+	1 => array('pipe', 'w'), // stdout
+	2 => array('pipe', 'w'), // strerr
+);
+
+$other_opts = array('suppress_errors' => false, 'binary_pipes' => true);
+
+$cmd = (substr(PHP_OS, 0, 3) == 'WIN') ? 'dir' : 'ls';
+$p = proc_open($cmd, $descs, $pipes, '.', NULL, $other_opts);
+
+if (is_resource($p)) {
+	$data = '';
+
+	while (1) {	
+		$w = $e = NULL;
+		$n = stream_select($pipes, $w, $e, 300);
+
+		if ($n === false) {
+			echo "no streams \n";
+			break;
+		} else if ($n === 0) {
+			echo "process timed out\n";
+			proc_terminate($p, 9);
+			break;
+		} else if ($n > 0) {
+			$line = fread($pipes[1], 8192);
+			if (strlen($line) == 0) {
+				/* EOF */
+				break;
+			}
+			$data .= $line;
+		}
+	}
+	var_dump(strlen($data));
+
+	$ret = proc_close($p);
+	var_dump($ret);
+} else {
+	echo "no process\n";
+}
+?>
+==DONE==
+--EXPECTF--
+int(%d)
+int(0)
+==DONE==
--- a/ext/zlib/tests/bug_52944-win.phpt
+++ /dev/null
@@ -1,24 +0,0 @@
---TEST--
-Bug #52944 (segfault with zlib filter and corrupted data)
---SKIPIF--
-<?php if (!extension_loaded("zlib")) print "skip"; ?>
-<?php
-if (substr(PHP_OS, 0, 3) != 'WIN') {
-	die("skip windows only");
-}
---INI--
-allow_url_fopen=1
---FILE--
-<?php
-require dirname(__FILE__) . "/bug_52944_corrupted_data.inc";
-
-$fp = fopen('data://text/plain;base64,' . $data, 'r');
-stream_filter_append($fp, 'zlib.inflate', STREAM_FILTER_READ);
-var_dump(fread($fp,1));
-var_dump(fread($fp,1));
-fclose($fp);
-echo "Done.\n";
---EXPECT--
-string(1) "%"
-string(1) "C"
-Done.
--- a/ext/zlib/tests/bug_52944.phpt
+++ b/ext/zlib/tests/bug_52944.phpt
@@ -3,9 +3,6 @@ Bug #52944 (segfault with zlib filter an
 --SKIPIF--
 <?php if (!extension_loaded("zlib")) print "skip"; ?>
 <?php
-if (substr(PHP_OS, 0, 3) == 'WIN') {
-	die("skip not for windows");
-}
 if (PHP_OS == 'Darwin') {
 	die("skip not for Darwin");
 }
@@ -13,6 +10,10 @@ if (PHP_OS == 'Darwin') {
 allow_url_fopen=1
 --FILE--
 <?php
+/* NOTE this test can fail on asm builds of zlib 1.2.5 or 
+   1.2.7 on at least Windows and Darwin. Using unoptimized
+   zlib build fixes the issue. */
+
 require dirname(__FILE__) . "/bug_52944_corrupted_data.inc";
 
 $fp = fopen('data://text/plain;base64,' . $data, 'r');
--- a/sapi/fpm/fpm/fpm_conf.c
+++ b/sapi/fpm/fpm/fpm_conf.c
@@ -540,12 +540,17 @@ static char *fpm_conf_set_array(zval *ke
 	kv->key = strdup(Z_STRVAL_P(key));
 
 	if (!kv->key) {
+		free(kv);
 		return "fpm_conf_set_array: strdup(key) failed";
 	}
 
 	if (convert_to_bool) {
 		char *err = fpm_conf_set_boolean(value, &subconf, 0);
-		if (err) return err;
+		if (err) {
+			free(kv->key);
+			free(kv);
+			return err;
+		}
 		kv->value = strdup(b ? "1" : "0");
 	} else {
 		kv->value = strdup(Z_STRVAL_P(value));
@@ -556,6 +561,7 @@ static char *fpm_conf_set_array(zval *ke
 
 	if (!kv->value) {
 		free(kv->key);
+		free(kv);
 		return "fpm_conf_set_array: strdup(value) failed";
 	}
 
@@ -578,6 +584,7 @@ static void *fpm_worker_pool_config_allo
 	wp->config = malloc(sizeof(struct fpm_worker_pool_config_s));
 
 	if (!wp->config) { 
+		fpm_worker_pool_free(wp);
 		return 0;
 	}
 
@@ -1002,7 +1009,7 @@ static int fpm_conf_process_all_pools()
 			nb_ext = 0;
 
 			/* find the number of extensions */
-			while ((ext = strtok(limit_extensions, " \t"))) {
+			while (strtok(limit_extensions, " \t")) {
 				limit_extensions = NULL;
 				nb_ext++;
 			}
@@ -1024,8 +1031,8 @@ static int fpm_conf_process_all_pools()
 				nb_ext = 0;
 
 				/* parse the string and save the extension in the array */
-				while ((ext = strtok(security_limit_extensions, " \t"))) {
-					security_limit_extensions = NULL;
+				while ((ext = strtok(limit_extensions, " \t"))) {
+					limit_extensions = NULL;
 					wp->limit_extensions[nb_ext++] = strdup(ext);
 				}
 
@@ -1107,6 +1114,7 @@ int fpm_conf_write_pid() /* {{{ */
 
 		if (len != write(fd, buf, len)) {
 			zlog(ZLOG_SYSERROR, "Unable to write to the PID file.");
+			close(fd);
 			return -1;
 		}
 		close(fd);
@@ -1460,6 +1468,7 @@ int fpm_conf_load_ini_file(char *filenam
 
 	if (ini_recursion++ > 4) {
 		zlog(ZLOG_ERROR, "failed to include more than 5 files recusively");
+		close(fd);
 		return -1;
 	}
 
--- a/sapi/fpm/fpm/fpm_log.c
+++ b/sapi/fpm/fpm/fpm_log.c
@@ -57,7 +57,9 @@ int fpm_log_open(int reopen) /* {{{ */
 			wp->log_fd = fd;
 		}
 
-		fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
+		if (0 > fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC)) {
+			zlog(ZLOG_WARNING, "failed to change attribute of access_log");
+		}
 	}
 
 	return ret;
@@ -237,7 +239,7 @@ int fpm_log_write(char *log_format TSRML
 
 				case 'f': /* script */
 					if (!test) {
-						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s",  proc.script_filename && *proc.script_filename ? proc.script_filename : "-");
+						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s",  *proc.script_filename ? proc.script_filename : "-");
 					}
 					break;
 
@@ -249,7 +251,7 @@ int fpm_log_write(char *log_format TSRML
 
 				case 'm': /* method */
 					if (!test) {
-						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", proc.request_method && *proc.request_method ? proc.request_method : "-");
+						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", *proc.request_method ? proc.request_method : "-");
 					}
 					break;
 
@@ -347,19 +349,19 @@ int fpm_log_write(char *log_format TSRML
 
 				case 'q': /* query_string */
 					if (!test) {
-						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", proc.query_string ? proc.query_string : "");
+						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", proc.query_string);
 					}
 					break;
 
 				case 'Q': /* '?' */
 					if (!test) {
-						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", proc.query_string && *proc.query_string  ? "?" : "");
+						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", *proc.query_string  ? "?" : "");
 					}
 					break;
 
 				case 'r': /* request URI */
 					if (!test) {
-						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", proc.request_uri ? proc.request_uri : "-");
+						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", proc.request_uri);
 					}
 					break;
 
@@ -397,7 +399,7 @@ int fpm_log_write(char *log_format TSRML
 
 				case 'u': /* remote user */
 					if (!test) {
-						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", proc.auth_user ? proc.auth_user : "-");
+						len2 = snprintf(b, FPM_LOG_BUFFER - len, "%s", proc.auth_user);
 					}
 					break;
 
--- a/sapi/fpm/fpm/fpm_main.c
+++ b/sapi/fpm/fpm/fpm_main.c
@@ -1098,7 +1098,7 @@ static void init_request_info(TSRMLS_D)
 
 #define APACHE_PROXY_FCGI_PREFIX "proxy:fcgi://"
 		/* Fix proxy URLs in SCRIPT_FILENAME generated by Apache mod_proxy_fcgi:
-		 *     proxy:fcgi://localhost:9000/some-dir/info.php/test
+		 *     proxy:fcgi://localhost:9000/some-dir/info.php/test?foo=bar
 		 * should be changed to:
 		 *     /some-dir/info.php/test
 		 * See: http://bugs.php.net/bug.php?id=54152
@@ -1118,6 +1118,11 @@ static void init_request_info(TSRMLS_D)
 				memmove(env_script_filename, p, strlen(p) + 1);
 				apache_was_here = 1;
 			}
+			/* ignore query string if sent by Apache (RewriteRule) */
+			p = strchr(env_script_filename, '?');
+			if (p) {
+				*p =0;
+			}
 		}
 
 		if (CGIG(fix_pathinfo)) {
@@ -1173,119 +1178,123 @@ static void init_request_info(TSRMLS_D)
 				int len = script_path_translated_len;
 				char *ptr;
 
-				while ((ptr = strrchr(pt, '/')) || (ptr = strrchr(pt, '\\'))) {
-					*ptr = 0;
-					if (stat(pt, &st) == 0 && S_ISREG(st.st_mode)) {
-						/*
-						 * okay, we found the base script!
-						 * work out how many chars we had to strip off;
-						 * then we can modify PATH_INFO
-						 * accordingly
-						 *
-						 * we now have the makings of
-						 * PATH_INFO=/test
-						 * SCRIPT_FILENAME=/docroot/info.php
-						 *
-						 * we now need to figure out what docroot is.
-						 * if DOCUMENT_ROOT is set, this is easy, otherwise,
-						 * we have to play the game of hide and seek to figure
-						 * out what SCRIPT_NAME should be
-						 */
-						int ptlen = strlen(pt);
-						int slen = len - ptlen;
-						int pilen = env_path_info ? strlen(env_path_info) : 0;
-						int tflag = 0;
-						char *path_info;
-						if (apache_was_here) {
-							/* recall that PATH_INFO won't exist */
-							path_info = script_path_translated + ptlen;
-							tflag = (slen != 0 && (!orig_path_info || strcmp(orig_path_info, path_info) != 0));
-						} else {
-							path_info = env_path_info ? env_path_info + pilen - slen : NULL;
-							tflag = (orig_path_info != path_info);
-						}
-
-						if (tflag) {
-							if (orig_path_info) {
-								char old;
-
-								_sapi_cgibin_putenv("ORIG_PATH_INFO", orig_path_info TSRMLS_CC);
-								old = path_info[0];
-								path_info[0] = 0;
-								if (!orig_script_name ||
-									strcmp(orig_script_name, env_path_info) != 0) {
-									if (orig_script_name) {
-										_sapi_cgibin_putenv("ORIG_SCRIPT_NAME", orig_script_name TSRMLS_CC);
+				if (pt) {
+					while ((ptr = strrchr(pt, '/')) || (ptr = strrchr(pt, '\\'))) {
+						*ptr = 0;
+						if (stat(pt, &st) == 0 && S_ISREG(st.st_mode)) {
+							/*
+							 * okay, we found the base script!
+							 * work out how many chars we had to strip off;
+							 * then we can modify PATH_INFO
+							 * accordingly
+							 *
+							 * we now have the makings of
+							 * PATH_INFO=/test
+							 * SCRIPT_FILENAME=/docroot/info.php
+							 *
+							 * we now need to figure out what docroot is.
+							 * if DOCUMENT_ROOT is set, this is easy, otherwise,
+							 * we have to play the game of hide and seek to figure
+							 * out what SCRIPT_NAME should be
+							 */
+							int ptlen = strlen(pt);
+							int slen = len - ptlen;
+							int pilen = env_path_info ? strlen(env_path_info) : 0;
+							int tflag = 0;
+							char *path_info;
+							if (apache_was_here) {
+								/* recall that PATH_INFO won't exist */
+								path_info = script_path_translated + ptlen;
+								tflag = (slen != 0 && (!orig_path_info || strcmp(orig_path_info, path_info) != 0));
+							} else {
+								path_info = env_path_info ? env_path_info + pilen - slen : NULL;
+								tflag = (orig_path_info != path_info);
+							}
+
+							if (tflag) {
+								if (orig_path_info) {
+									char old;
+
+									_sapi_cgibin_putenv("ORIG_PATH_INFO", orig_path_info TSRMLS_CC);
+									old = path_info[0];
+									path_info[0] = 0;
+									if (!orig_script_name ||
+										strcmp(orig_script_name, env_path_info) != 0) {
+										if (orig_script_name) {
+											_sapi_cgibin_putenv("ORIG_SCRIPT_NAME", orig_script_name TSRMLS_CC);
+										}
+										SG(request_info).request_uri = _sapi_cgibin_putenv("SCRIPT_NAME", env_path_info TSRMLS_CC);
+									} else {
+										SG(request_info).request_uri = orig_script_name;
 									}
-									SG(request_info).request_uri = _sapi_cgibin_putenv("SCRIPT_NAME", env_path_info TSRMLS_CC);
-								} else {
-									SG(request_info).request_uri = orig_script_name;
+									path_info[0] = old;
 								}
-								path_info[0] = old;
+								env_path_info = _sapi_cgibin_putenv("PATH_INFO", path_info TSRMLS_CC);
 							}
-							env_path_info = _sapi_cgibin_putenv("PATH_INFO", path_info TSRMLS_CC);
-						}
-						if (!orig_script_filename ||
-							strcmp(orig_script_filename, pt) != 0) {
-							if (orig_script_filename) {
-								_sapi_cgibin_putenv("ORIG_SCRIPT_FILENAME", orig_script_filename TSRMLS_CC);
-							}
-							script_path_translated = _sapi_cgibin_putenv("SCRIPT_FILENAME", pt TSRMLS_CC);
-						}
-						TRANSLATE_SLASHES(pt);
-
-						/* figure out docroot
-						 * SCRIPT_FILENAME minus SCRIPT_NAME
-						 */
-						if (env_document_root) {
-							int l = strlen(env_document_root);
-							int path_translated_len = 0;
-							char *path_translated = NULL;
-
-							if (l && env_document_root[l - 1] == '/') {
-								--l;
+							if (!orig_script_filename ||
+								strcmp(orig_script_filename, pt) != 0) {
+								if (orig_script_filename) {
+									_sapi_cgibin_putenv("ORIG_SCRIPT_FILENAME", orig_script_filename TSRMLS_CC);
+								}
+								script_path_translated = _sapi_cgibin_putenv("SCRIPT_FILENAME", pt TSRMLS_CC);
 							}
+							TRANSLATE_SLASHES(pt);
 
-							/* we have docroot, so we should have:
-							 * DOCUMENT_ROOT=/docroot
-							 * SCRIPT_FILENAME=/docroot/info.php
+							/* figure out docroot
+							 * SCRIPT_FILENAME minus SCRIPT_NAME
 							 */
+							if (env_document_root) {
+								int l = strlen(env_document_root);
+								int path_translated_len = 0;
+								char *path_translated = NULL;
 
-							/* PATH_TRANSLATED = DOCUMENT_ROOT + PATH_INFO */
-							path_translated_len = l + (env_path_info ? strlen(env_path_info) : 0);
-							path_translated = (char *) emalloc(path_translated_len + 1);
-							memcpy(path_translated, env_document_root, l);
-							if (env_path_info) {
-								memcpy(path_translated + l, env_path_info, (path_translated_len - l));
-							}
-							path_translated[path_translated_len] = '\0';
-							if (orig_path_translated) {
-								_sapi_cgibin_putenv("ORIG_PATH_TRANSLATED", orig_path_translated TSRMLS_CC);
-							}
-							env_path_translated = _sapi_cgibin_putenv("PATH_TRANSLATED", path_translated TSRMLS_CC);
-							efree(path_translated);
-						} else if (	env_script_name &&
-									strstr(pt, env_script_name)
-						) {
-							/* PATH_TRANSLATED = PATH_TRANSLATED - SCRIPT_NAME + PATH_INFO */
-							int ptlen = strlen(pt) - strlen(env_script_name);
-							int path_translated_len = ptlen + (env_path_info ? strlen(env_path_info) : 0);
-							char *path_translated = NULL;
-
-							path_translated = (char *) emalloc(path_translated_len + 1);
-							memcpy(path_translated, pt, ptlen);
-							if (env_path_info) {
-								memcpy(path_translated + ptlen, env_path_info, path_translated_len - ptlen);
-							}
-							path_translated[path_translated_len] = '\0';
-							if (orig_path_translated) {
-								_sapi_cgibin_putenv("ORIG_PATH_TRANSLATED", orig_path_translated TSRMLS_CC);
+								if (l && env_document_root[l - 1] == '/') {
+									--l;
+								}
+
+								/* we have docroot, so we should have:
+								 * DOCUMENT_ROOT=/docroot
+								 * SCRIPT_FILENAME=/docroot/info.php
+								 */
+
+								/* PATH_TRANSLATED = DOCUMENT_ROOT + PATH_INFO */
+								path_translated_len = l + (env_path_info ? strlen(env_path_info) : 0);
+								path_translated = (char *) emalloc(path_translated_len + 1);
+								memcpy(path_translated, env_document_root, l);
+								if (env_path_info) {
+									memcpy(path_translated + l, env_path_info, (path_translated_len - l));
+								}
+								path_translated[path_translated_len] = '\0';
+								if (orig_path_translated) {
+									_sapi_cgibin_putenv("ORIG_PATH_TRANSLATED", orig_path_translated TSRMLS_CC);
+								}
+								env_path_translated = _sapi_cgibin_putenv("PATH_TRANSLATED", path_translated TSRMLS_CC);
+								efree(path_translated);
+							} else if (	env_script_name &&
+										strstr(pt, env_script_name)
+							) {
+								/* PATH_TRANSLATED = PATH_TRANSLATED - SCRIPT_NAME + PATH_INFO */
+								int ptlen = strlen(pt) - strlen(env_script_name);
+								int path_translated_len = ptlen + (env_path_info ? strlen(env_path_info) : 0);
+								char *path_translated = NULL;
+
+								path_translated = (char *) emalloc(path_translated_len + 1);
+								memcpy(path_translated, pt, ptlen);
+								if (env_path_info) {
+									memcpy(path_translated + ptlen, env_path_info, path_translated_len - ptlen);
+								}
+								path_translated[path_translated_len] = '\0';
+								if (orig_path_translated) {
+									_sapi_cgibin_putenv("ORIG_PATH_TRANSLATED", orig_path_translated TSRMLS_CC);
+								}
+								env_path_translated = _sapi_cgibin_putenv("PATH_TRANSLATED", path_translated TSRMLS_CC);
+								efree(path_translated);
 							}
-							env_path_translated = _sapi_cgibin_putenv("PATH_TRANSLATED", path_translated TSRMLS_CC);
-							efree(path_translated);
+							break;
 						}
-						break;
 					}
+				} else {
+					ptr = NULL;
 				}
 				if (!ptr) {
 					/*
--- a/sapi/fpm/fpm/fpm_signals.c
+++ b/sapi/fpm/fpm/fpm_signals.c
@@ -145,7 +145,9 @@ static void sig_soft_quit(int signo) /*
 
 	/* closing fastcgi listening socket will force fcgi_accept() exit immediately */
 	close(0);
-	socket(AF_UNIX, SOCK_STREAM, 0);
+	if (0 > socket(AF_UNIX, SOCK_STREAM, 0)) {
+		zlog(ZLOG_WARNING, "failed to create a new socket");
+	}
 	fpm_php_soft_quit();
 	errno = saved_errno;
 }
--- a/sapi/fpm/fpm/fpm_sockets.c
+++ b/sapi/fpm/fpm/fpm_sockets.c
@@ -167,7 +167,7 @@ static int fpm_sockets_new_listening_soc
 {
 	int flags = 1;
 	int sock;
-	mode_t saved_umask;
+	mode_t saved_umask = 0;
 
 	sock = socket(sa->sa_family, SOCK_STREAM, 0);
 
@@ -176,11 +176,14 @@ static int fpm_sockets_new_listening_soc
 		return -1;
 	}
 
-	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof(flags));
+	if (0 > setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof(flags))) {
+		zlog(ZLOG_WARNING, "failed to change socket attribute");
+	}
 
 	if (wp->listen_address_domain == FPM_AF_UNIX) {
 		if (fpm_socket_unix_test_connect((struct sockaddr_un *)sa, socklen) == 0) {
 			zlog(ZLOG_ERROR, "An another FPM instance seems to already listen on %s", ((struct sockaddr_un *) sa)->sun_path);
+			close(sock);
 			return -1;
 		}
 		unlink( ((struct sockaddr_un *) sa)->sun_path);
@@ -192,6 +195,7 @@ static int fpm_sockets_new_listening_soc
 		if (wp->listen_address_domain == FPM_AF_UNIX) {
 			umask(saved_umask);
 		}
+		close(sock);
 		return -1;
 	}
 
@@ -203,6 +207,7 @@ static int fpm_sockets_new_listening_soc
 		if (wp->socket_uid != -1 || wp->socket_gid != -1) {
 			if (0 > chown(path, wp->socket_uid, wp->socket_gid)) {
 				zlog(ZLOG_SYSERROR, "failed to chown() the socket '%s'", wp->config->listen_address);
+				close(sock);
 				return -1;
 			}
 		}
@@ -210,6 +215,7 @@ static int fpm_sockets_new_listening_soc
 
 	if (0 > listen(sock, wp->config->listen_backlog)) {
 		zlog(ZLOG_SYSERROR, "failed to listen to address '%s'", wp->config->listen_address);
+		close(sock);
 		return -1;
 	}
 
--- a/sapi/fpm/fpm/fpm_stdio.c
+++ b/sapi/fpm/fpm/fpm_stdio.c
@@ -34,6 +34,7 @@ int fpm_stdio_init_main() /* {{{ */
 
 	if (0 > dup2(fd, STDIN_FILENO) || 0 > dup2(fd, STDOUT_FILENO)) {
 		zlog(ZLOG_SYSERROR, "failed to init stdio: dup2()");
+		close(fd);
 		return -1;
 	}
 	close(fd);
@@ -294,7 +295,9 @@ int fpm_stdio_open_error_log(int reopen)
 			zlog_set_fd(fpm_globals.error_log_fd);
 		}
 	}
-	fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
+	if (0 > fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC)) {
+		zlog(ZLOG_WARNING, "failed to change attribute of error_log");
+	}
 	return 0;
 }
 /* }}} */
--- a/sapi/fpm/fpm/fpm_worker_pool.c
+++ b/sapi/fpm/fpm/fpm_worker_pool.c
@@ -18,6 +18,21 @@
 
 struct fpm_worker_pool_s *fpm_worker_all_pools;
 
+void fpm_worker_pool_free(struct fpm_worker_pool_s *wp) /* {{{ */
+{
+	if (wp->config) {
+		free(wp->config);
+	}
+	if (wp->user) {
+		free(wp->user);
+	}
+	if (wp->home) {
+		free(wp->home);
+	}
+	free(wp);
+}
+/* }}} */
+
 static void fpm_worker_pool_cleanup(int which, void *arg) /* {{{ */
 {
 	struct fpm_worker_pool_s *wp, *wp_next;
@@ -29,10 +44,7 @@ static void fpm_worker_pool_cleanup(int
 		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
 			fpm_scoreboard_free(wp->scoreboard);
 		}
-		free(wp->config);
-		free(wp->user);
-		free(wp->home);
-		free(wp);
+		fpm_worker_pool_free(wp);
 	}
 	fpm_worker_all_pools = NULL;
 }
--- a/sapi/fpm/fpm/fpm_worker_pool.h
+++ b/sapi/fpm/fpm/fpm_worker_pool.h
@@ -45,6 +45,7 @@ struct fpm_worker_pool_s {
 };
 
 struct fpm_worker_pool_s *fpm_worker_pool_alloc();
+void fpm_worker_pool_free(struct fpm_worker_pool_s *wp);
 int fpm_worker_pool_init_main();
 
 extern struct fpm_worker_pool_s *fpm_worker_all_pools;
--- /dev/null
+++ b/tests/basic/req60524-win.phpt
@@ -0,0 +1,13 @@
+--TEST--
+Req #60524 (Specify temporary directory)
+--INI--
+sys_temp_dir=C:\Windows
+--SKIPIF--
+<?php
+if( substr(PHP_OS, 0, 3) != "WIN" )
+  die('skip Run only on Windows');
+?>
+--FILE--
+<?php echo sys_get_temp_dir(); ?>
+--EXPECT--
+C:\\Windows
--- a/tests/basic/req60524.phpt
+++ b/tests/basic/req60524.phpt
@@ -2,6 +2,12 @@
 Req #60524 (Specify temporary directory)
 --INI--
 sys_temp_dir=/path/to/temp/dir
+--SKIPIF--
+<?php
+if (substr(PHP_OS, 0, 3) == 'WIN') {
+    die('skip non-windows only test');
+}
+?>
 --FILE--
 <?php echo sys_get_temp_dir(); ?>
 --EXPECT--
--- a/win32/build/libs_version.txt
+++ b/win32/build/libs_version.txt
@@ -20,6 +20,6 @@ libtidy-20090325
 libtidy-20090406
 libxslt-1.1.27
 libxml-2.7.8
-libxml-2.9.0
+libxml-2.9.1
 openssl-0.9.8y
 openssl-1.0.1e
