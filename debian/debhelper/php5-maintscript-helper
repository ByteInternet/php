# php5-maintscript-helper - Php5 helper function for maintainer scripts
# Copyright (C) 2012 Arno Töll <debian@toell.net>
#               2013 Ondřej Surý <ondrej@sury.org>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



#
# VARIABLES
#


# global environment variables used by php5-maintscript-helper:
# * PHP5_MAINTSCRIPT_DEBUG:
#				set this to any non-zero value to get debug output
# * PHP5_MAINTSCRIPT_HELPER_QUIET:
#				set this to any non-zero value to omit any output
# * EXPORT_PHP5_MAINTSCRIPT_HELPER:
#				will be defined by php5-maintscript-helper
#				to avoid inclusion loops. Do not set this
#				variable manually
# * PHP5_NEED_ACTION:
#				will be defined if a function call wants to
#				override the behavior of php5_needs_action.
#				Do not rely on this variable. It is considered
#				an implementation detail.
# * PHP5_MAINTSCRIPT_NAME
# * PHP5_MAINTSCRIPT_PACKAGE
# * PHP5_MAINTSCRIPT_METHOD
# * PHP5_MAINTSCRIPT_ARGUMENT
#				these variables contain information about the
#				maintainer script which is calling the
#				maintscript-helper. It contains arguments which
#				dpkg supplies to maintainer scripts and similar
#				information. These variables are an
#				implementation detail and not to be changed.
#
#				You might want to set them manually only if you
#				are calling php5-maintscript-helper from
#				some place which does not preserve the original
#				script arguments for example when calling from
#				a subfunction instead of the main function in
#				your maintainer script

#
# INITIALIZATION
#

if [ -n "${EXPORT_PHP5_MAINTSCRIPT_HELPER:-}" ] ; then
	return
else
	EXPORT_PHP5_MAINTSCRIPT_HELPER=1

	if [ -n "${PHP5_MAINTSCRIPT_DEBUG:-}" ] ; then
		set -x
	fi

	if [ -z "$1" ] ; then
		echo "You must invoke php5-maintscript-helper with an unmodified environment when sourcing it" >&2
		return 1
	fi

	PHP5_MAINTSCRIPT_NAME="$DPKG_MAINTSCRIPT_NAME"
	[ "$PHP5_MAINTSCRIPT_NAME" ] || PHP5_MAINTSCRIPT_NAME="${0##*.}"

	case "$PHP5_MAINTSCRIPT_NAME" in
		preinst|prerm|postrm|postinst)
			# yay - recognized script
		;;
		*)
			echo "php5-maintscript-helper invoked from an unrecognized maintainer script: exiting" >&2
			return 1
		;;
	esac

	PHP5_MAINTSCRIPT_PACKAGE="$DPKG_MAINTSCRIPT_PACKAGE"
	if [ -z "$PHP5_MAINTSCRIPT_PACKAGE" ]; then
		PHP5_MAINTSCRIPT_PACKAGE="${0##*/}"
		PHP5_MAINTSCRIPT_PACKAGE="${PHP5_MAINTSCRIPT_PACKAGE%.*}"
	fi

	if [ -z "$PHP5_MAINTSCRIPT_METHOD" ] ; then
		PHP5_MAINTSCRIPT_METHOD="$1"
	fi

	case "$PHP5_MAINTSCRIPT_METHOD" in
		install|upgrade|abort-upgrade|configure|abort-remove|abort-remove|abort-deconfigure|remove|failed-upgrade|purge|disappear|abort-install)
			# yay - recognized script
		;;
		*)
			echo "php5-maintscript-helper invoked from a modified environment. Please hint required arguments manually" >&2
			return 1
		;;
	esac



	if [ -z "$PHP5_MAINTSCRIPT_ARGUMENT" ] ; then
		PHP5_MAINTSCRIPT_ARGUMENT="${2:-}"
	fi

fi

#
# FUNCTIONS
#

#
# Function php5_msg
#	print out a warning to both, the syslog and a local standard output.
#	This function should generally be used to display messages related to
#	the web server in maintainer scripts.
# Parameters:
#	priority
#		The message priority. Recognized values are the same as defined
#		by syslog(3), thus: one among debug, info, notice, warning,
#		err, crit, alert, emerg.
#		If no known priority is recognized, the priority is set to
#		"warning".
#	message
#		The message as a string. It is printed out verbatim.
# Behavior:
#	No message is displayed if PHP5_MAINTSCRIPT_HELPER_QUIET is defined
# Returns:
#	this function always returns 0
# Since: 5.5.0+dfsg-7
php5_msg()
{
	local PRIORITY="$1"
	local MSG="$2"
	[ -z "$PHP5_MAINTSCRIPT_HELPER_QUIET" ] && echo "$MSG" >&2
	[ -x /usr/bin/logger ] || return 0
	case "$PRIORITY" in
		debug|info|notice|warning|err|crit|alert|emerg)
		;;
		*)
			PRIORITY="warning"
		;;
	esac
	local LOGGER="/usr/bin/logger -p daemon.$PRIORITY -t $PHP5_MAINTSCRIPT_PACKAGE "
	$LOGGER "$MSG" || return 0
}

#
# Function php5_needs_action
#	succeeds if the package invoking the maintscript helper
#	needs any work. This function can be used as a conditional whether a
#	certain function should be executed by means of the package state.
#	Note, calling some other functions may change the outcome of this
#	function, depending on the action required
#Parameters:
#	none
# Returns:
#	0 if an older version of the maintainer script invoking the helper is
#	already installed
#	1 otherwise
# Since: 2.4.1-3
php5_needs_action()
{
	# Summary how the maintscript behaves:
	# preinst:
	#	Not sure why anyone would like to call this function in preinst. Die loud.
	# prerm remove:
	#	Basically the same as postrm. If a maintainer would like to
	#	disable his module before removing his stuff, be it.
	#	However, we have nothing useful to do if we're called in any
	#	other way than "remove" in prerm.
	# postinst configure
	#	Probably the most important invokation. When invoked in configure we:
	#	- enable the piece of configuration on fresh installs
	#	- do nothing on upgrades UNLESS the configuration was removed automatically in the past
	# postrm remove|purge
	#	- disable the configuration, mark it as automatically disabled in remove
	#	- disable the configuration, remove any trace we have on purge

	case "$PHP5_MAINTSCRIPT_NAME" in
	preinst)
		php5_msg "info" "php5_needs_action: The maintainer helper can not be called in preinst"
		return 1
		;;
	prerm|postrm)
		case "$PHP5_MAINTSCRIPT_METHOD" in
		remove|purge)
			return 0
			;;
		*)
			return 1
			;;
		esac
		;;
	postinst)
		if [ "$PHP5_MAINTSCRIPT_METHOD" = "configure" ] ; then
			# act on fresh installs
			[ -z "$PHP5_MAINTSCRIPT_ARGUMENT" ] && return 0
			# act if someone told us
			[ -n "$PHP5_NEED_ACTION" ] && return 0
		fi
		;;
	esac

	return 1
}


#
# Function php5_invoke
#	invokes an Apache 2 configuration helper to enable or disable a
#	particular piece of configuration, a site or a module. It carefully
#	checks whether the supplied configuration snippet exists and reloads the
#	web server if the site administrator desires that by calling the
#	php5_reload function.
# Parameters:
#	command - The command to invoke. Recognized commands are "enconf",
#		"enmod", "ensite", "disconf", "dismod", "dissite"
#
#       sapi - Either the specific SAPI (apache2, apache2filter, fpm,
#              cgi, cli, embed) or ALL
#
#	arguments
#		- A single argument (e.g. a module) which shall be
#		  enabled or disabled respectively. Do not enable module
#		  dependencies that way, instead use module dependencies as
#		  documented in </usr/share/doc/php5/PACKAGING>.
#
#	rcd-action
#		- An optional rc.d action to override the default which is to
#		  reload the web server for sites and configurations but restart
#		  it for modules. Recognized arguments are "restart" and "reload"
# Returns
#	0 if the changes could be activated
#	1 otherwise
# Since: 5.5.0+dsfg-7
php5_invoke()
{
    local CMD=$1
    local SAPI=$2
    local MOD=$3
    local check_switch=""
    local invoke_string=""
    local rcd_action="restart"
    local rcd_scripts=""
    local sapi_list=""

    [ -x "/usr/sbin/php5$CMD" ] || return 1
    [ -x "/usr/sbin/php5query" ] || return 1

    sapi_list="$SAPI"
    case "$SAPI" in
	apache2|apache2filter)
	    rcd_scripts="apache2"
	    ;;
	fpm)
	    rcd_scripts="php5-fpm"
	    ;;
	cli|cgi|embed)
	    rcd_scripts=""
	    ;;
	ALL)
	    rcd_scripts="apache2 php5-fpm"
	    sapi_list="$(php5query -S)"
	    ;;
	*)
	    return 1
	    ;;
    esac

    for SAPI in $sapi_list; do
	case "$CMD" in
	    enmod)
		local php5query_ret=0
		php5query -s "$SAPI" -m "$MOD" > /dev/null 2>&1 || php5query_ret=$?
		if [ "$php5query_ret" -eq 0 ] ; then
		    # configuration is already enabled
		    php5_msg "info" "php5_invoke $MOD: already enabled for $SAPI SAPI"
		    PHP5_NEED_ACTION=1
		elif [ "$php5query_ret" -eq 32	 ] ; then
		    # the maintainer disabled the module
		    php5_msg "info" "php5_invoke $MOD: no action - module was disabled by maintainer for $SAPI SAPI"
		    return 0
		else
		    # coming here either means:
		    # a) we have no clue about the module (e.g. for upgrades prior to maintscript-helper
		    # b) it's a fresh install
		    PHP5_NEED_ACTION=1
		    php5$CMD -m -s "$SAPI" -q "$MOD" > /dev/null 2>&1 || return 1
		    php5_msg "info" "php5_invoke: Enable module $MOD for $SAPI SAPI"
		fi
		;;
	    dismod)
		local php5query_ret=0
		php5query -s "$SAPI" -m "$MOD" > /dev/null 2>&1 || php5query_ret=$?
		if [ "$php5query_ret" -eq 0 ] ; then
		    if [ "$PHP5_MAINTSCRIPT_NAME" = 'postrm' ] && [ "$PHP5_MAINTSCRIPT_METHOD" = "purge" ] ; then
			php5$CMD -p -f -s "$SAPI" -q "$MOD" || return 1
			php5_msg "info" "php5_invoke $PHP5_MAINTSCRIPT_NAME: Purging module $MOD for $SAPI SAPI"
			PHP5_NEED_ACTION=1
		    elif [ "$PHP5_MAINTSCRIPT_NAME" = 'postrm' ] || [ "$PHP5_MAINTSCRIPT_NAME" = 'prerm' ] ; then
			if [ "$PHP5_MAINTSCRIPT_METHOD" = "remove" ] ; then
			    php5$CMD -m -f -s "$SAPI" -q "$MOD" || return 1
			    php5_msg "info" "php5_invoke $PHP5_MAINTSCRIPT_NAME: Disable module $MOD for $SAPI SAPI"
			    PHP5_NEED_ACTION=1
			fi
		    else
			php5_msg "error" "php5_invoke: module $MOD not supported in $PHP5_MAINTSCRIPT_NAME for $SAPI SAPI"
			return 1
		    fi
		elif [ "$php5query_ret" -eq 32 ] || [ "$php5query_ret" -eq 33 ] ; then
		    if [ "$PHP5_MAINTSCRIPT_NAME" = 'postrm' ] && [ "$PHP5_MAINTSCRIPT_METHOD" = "purge" ] ; then
			php5_msg "info" "php5_invoke $PHP5_MAINTSCRIPT_NAME: Purging state for $MOD for $SAPI SAPI"
			# this will return RC=1
			( php5$CMD -p -f -s "$SAPI" -q "$MOD" > /dev/null 2>&1 )
		    else
			php5_msg "info" "php5_invoke $MOD $PHP5_MAINTSCRIPT_NAME: No action required for $SAPI SAPI"
		    fi
		else
		    php5_msg "info" "php5_invoke $MOD $PHP5_MAINTSCRIPT_NAME: No action required for $SAPI SAPI"
		fi
		;;
	    *)
		return 1
		;;
	esac
    done
	
    if [ -n "$rcd_scripts" -a -n "${PHP5_NEED_ACTION:-}" ] ; then
	php5_reload "$rcd_action" "$rcd_scripts"
    fi
}

#
# Function php5_reload
#	reloads the web server to activate a changed configuration. It does not
#	actually reload the web server if the current configuration fails to
#	parse.
# Parameters:
#	action - optional, can be 'reload' (default) or 'restart'
# Returns:
#	0 if the changes could be activated
#	1 otherwise
# Since: 2.4.1-1
php5_reload()
{
	local rcd_action
	local rcd_scripts="$2"

	if ! php5_needs_action ; then
		return 0
	fi

	case "${1:-}" in
	""|reload)
		rcd_action=reload
		;;
	restart)
		rcd_action=restart
		;;
	*)
		return 1
		;;
	esac

	for rcd_script in "$rcd_scripts"; do
		local rcd_ret=0
		invoke-rc.d --query $rcd_script $rcd_action > /dev/null 2>&1 || rcd_ret=$?
		case "$rcd_ret" in
			100)
				break
				;;
			104)
				;;
			*)
				php5_msg "err" "php5_reload: Your configuration is broken. Not ${rcd_action}ing ${rcd_script}."
				;;
		esac
		case "$rcd_script" in
			apache2)
				if apache2ctl configtest 2>/dev/null; then
					invoke-rc.d $rcd_script $rcd_action || true
				else
					php5_msg "err" "php5_reload: Your Apache 2 configuration is broken. Not ${action}ing Apache 2"
				fi
				;;
			*)
				invoke-rc.d $rcd_script $rcd_action
				;;
		esac
	done
}

# vim: syntax=sh sw=8 sts=8 sr noet
